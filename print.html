<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> 🇧🇷 Introdução</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 🇧🇷 Instalação</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> 🇧🇷 Olá, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 🇧🇷 Jogo de Adivinhação</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 🇧🇷 Conceitos Comuns de Programação</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 🇧🇷 Variáveis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 🇧🇷 Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 🇧🇷 Enums e Casamento de Padrões</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 🇧🇷 Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> 🇧🇷 Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> 🇧🇷 Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> 🇧🇷 Módulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> 🇧🇷 mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> 🇧🇷 Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> 🇧🇷 Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 🇧🇷 Vetores</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 🇧🇷 Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 🇧🇷 Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generics</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Syntax</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Lifetime syntax</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Is Rust OOP?</a></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#introdução" id="introdução"><h1>Introdução</h1></a>
<p>Seja bem vindo(a) ao “Linguagem de Programação Rust”, um livro introdutório
sobre Rust. Rust é uma linguagem de programação focada em segurança, eficiência
e concorrência. Seu <em>design</em> lhe permite criar programas com o desempenho e
controle de uma linguagem de baixo nível, mas com as abstrações poderosas de uma
linguagem de alto nível. Estas propriedades tornam Rust adequado para
programadores que têm experiência em linguagens como C e procuram por uma
alternativa mais segura, bem como para aqueles que vêm de linguagens como o
Python e que procuram por maneiras de escrever código com melhor desempenho sem
sacrificar a expressividade.</p>
<p>Rust executa a maioria das suas verificações de segurança e decisões de
gerenciamento de memória em tempo de compilação, para que o desempenho de
execução do seu programa não seja impactado. Isso torna a linguagem útil em um
número de casos para os quais outras linguagens não são adequadas: programas com
requisitos de tempo e espaço previsíveis, incorporação de código em outras
linguagens e a escrita de código de baixo nível, como <em>drivers</em> de dispositivo e
sistemas operacionais. A linguagem Rust também é fantástica para aplicações web:
ela está por trás do site do registro de pacotes do Rust, <a href="https://crates.io/">crates.io</a>! Estamos
curiosos para saber o que <em>você</em> fará com Rust.</p>
<p>Este livro tem como público-alvo um leitor que já sabe como programar em pelo
menos uma linguagem de programação. Após ler este livro, você deve se sentir
confiante para escrever programas em Rust. Ensinaremos Rust através de exemplos
focados e pequenos, que se complementam gradualmente para demonstrar o uso de
várias características da linguagem Rust, bem como eles funcionam “nos
bastidores”.</p>
<a class="header" href="print.html#sobre-a-tradução" id="sobre-a-tradução"><h2>Sobre a Tradução</h2></a>
<p>Esta é uma tradução <em>não oficial</em> da <a href="https://rust-lang.github.io/book">nova versão</a> do livro  “The Rust
Programming Language”. Várias porções desta tradução (assim como do original)
ainda estão incompletas. A <a href="https://doc.rust-lang.org/book">versão antiga</a> do livro (em inglês) ainda é a
leitura de referência recomendada da linguagem.</p>
<p>Sempre que possível, nos exemplos de código, optamos por usar nomes de
variáveis, funções e arquivos em português. Essa escolha foi feita para fins
didáticos, e se limita às porções de código de exemplo apresentadas. Os nomes
provenientes da biblioteca padrão da linguagem, bem como de <em>crates</em> já
existentes são mantidos no original em inglês, para que o código funcione
corretamente. (Ex: <code>Usuario</code> em vez de <code>User</code>, mas manteremos nomes como <code>Box</code>
em inglês). Para fins de compatibilidade, utilizaremos somente caracteres sem
acento e cedilha.</p>
<p>Apesar da escolha didática do livro, recomendamos que, ao escrever código “de
verdade” em Rust, utilize sempre que possível nomes em inglês, especialmente
para projetos <em>open source</em> a fim de tornar seu código acessível para uma maior
audiência.</p>
<a class="header" href="print.html#contribuindo-com-o-livro" id="contribuindo-com-o-livro"><h2>Contribuindo com o Livro</h2></a>
<p>Este livro é <em>open source</em>. Se encontrar um erro, por favor não hesite em abrir
uma <em>issue</em> ou enviar um <em>pull request</em> <a href="https://github.com/rust-br/rust-book-pt-br">no GitHub</a>. Leia
<a href="https://github.com/rust-br/rust-book-pt-br/blob/master/CONTRIBUTING-pt-br.md">CONTRIBUTING-pt-br.md</a> para mais detalhes.</p>
<a class="header" href="print.html#instalação" id="instalação"><h2>Instalação</h2></a>
<p>O primeiro passo para se usar a linguagem Rust é instalá-la. Você vai precisar
de uma conexão com a internet para executar os comandos contidos neste
capítulo, pois vamos baixar o Rust da internet.</p>
<p>Iremos mostrar diversos comandos usando o terminal, e todas as linhas que se
referem ao terminal iniciam com <code>$</code>. Você não precisa digitar o caractere <code>$</code>,
ele serve apenas para indicar o início de cada comando. Você vai notar que
muitos tutorias disponíveis por aí seguem esta convenção: <code>$</code> para comandos que
são executados como um usuário normal, e <code>#</code> para comandos que você deve
executar como administrador. As linhas que não iniciam com o caractere <code>$</code>
mostram o <em>output</em> (saída) do comando anterior.</p>
<a class="header" href="print.html#instalando-no-linux-ou-mac" id="instalando-no-linux-ou-mac"><h3>Instalando no Linux ou Mac</h3></a>
<p>Se você está em um ambiente Linux ou Mac, tudo o que você precisa é abrir um
terminal e digitar o seguinte comando:</p>
<pre><code class="language-text">$ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Este comando vai baixar um script e iniciar a instalação. Talvez seja solicitado
que você digite sua senha. Se tudo ocorrer bem, a mensagem abaixo vai aparecer:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>Claro, se você não aprova o uso do <code>curl | sh</code>, você pode baixar o <em>script</em>,
inspecioná-lo e executá-lo da maneira que achar melhor.</p>
<p>O <em>script</em> de instalação já adiciona automaticamente o Rust à variável PATH do
seu sistema logo após o seu próximo <em>login</em>. Se você quiser usar o Rust
imediatamente, execute o seguinte comando no seu terminal:</p>
<pre><code class="language-text">$ source $HOME/.cargo/env
</code></pre>
<p>Outra opção é adicionar a linha abaixo no seu <code>~/.bash_profile</code>:</p>
<pre><code class="language-text">$ export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
<a class="header" href="print.html#instalando-no-windows" id="instalando-no-windows"><h3>Instalando no Windows</h3></a>
<p>No Windows, visite o <em>site</em>
<a href="https://rustup.rs/">https://rustup.rs</a><!-- ignore --> e siga as instruções para
baixar o arquivo rustup-init.exe. Execute este arquivo e siga as demais
instruções que aparecerem na sua tela.</p>
<p>O restante dos comandos específicos do Windows neste livro partem da premissa de
que você está utilizando o <code>cmd</code> como o seu <em>shell</em>. Se você está usando um
<em>shell</em> diferente, talvez você poderá usar os mesmos comandos que os usuários de
Linux ou Mac usam. Se algum comando não funcionar, consulte a documentação
referente ao <em>shell</em> que você está utilizando.</p>
<a class="header" href="print.html#instalação-customizada" id="instalação-customizada"><h3>Instalação customizada</h3></a>
<p>Se, por alguma razão, você preferir não usar o rustup.rs, consulte <a href="https://www.rust-lang.org/pt-BR/install.html">a página de
instalação do Rust</a> para outras
opções de instalação.</p>
<a class="header" href="print.html#atualizando-o-rust" id="atualizando-o-rust"><h3>Atualizando o Rust</h3></a>
<p>Tendo o Rust instalado na sua máquina, atualizar para a última versão é fácil.
Do seu <em>shell</em>, execute o <em>script</em> de atualização:</p>
<pre><code class="language-text">$ rustup update
</code></pre>
<a class="header" href="print.html#desinstalando" id="desinstalando"><h3>Desinstalando</h3></a>
<p>Desinstalar Rust é tão fácil quanto instalá-lo. Do seu <em>shell</em>, execute o
<em>script</em> de desinstalação:</p>
<pre><code class="language-text">$ rustup self uninstall
</code></pre>
<a class="header" href="print.html#solução-de-problemas" id="solução-de-problemas"><h3>Solução de Problemas</h3></a>
<p>Após Rust ser instalado em sua máquina, você pode abrir o seu <em>shell</em>, e digitar
a linha abaixo:</p>
<pre><code class="language-text">$ rustc --version
</code></pre>
<p>Você deverá ver a versão, o <em>hash</em> e a data do <em>commit</em> em um formato
similar ao seguinte, indicando a última estável mais recente no momento da
instalação:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>Se aparecer a mensagem acima, Rust foi instalado com sucesso!
Parabéns!</p>
<p>Se não aparecer a mensagem acima e você está em um ambiente Windows, verifique
se o Rust aparece na variável <code>%PATH%</code> do seu sistema.</p>
<p>Se mesmo assim não funcionar, existem vários lugares onde você pode pedir ajuda.
A maneira mais fácil é pedir ajuda no
<a href="irc://irc.mozilla.org/#rust">canal IRC #rust do irc.mozilla.org</a><!-- ignore -->, que você pode acessar
via <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. Você vai falar com vários outros <em>Rustaceans</em> (um apelido
bobo que usamos entre nós) que podem ajudá-lo em suas dúvidas. Você também pode
buscar ajuda no <a href="https://users.rust-lang.org/">fórum do Rust</a> e no <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<a class="header" href="print.html#documentação-local" id="documentação-local"><h3>Documentação local</h3></a>
<p>O instalador também inclui uma cópia local da documentação para que você possa
acessá-la <em>offline</em>. Execute o comando <code>rustup doc</code> para abrir a documentação
local no seu navegador.</p>
<p>Sempre que você se deparar com um tipo ou função fornecido pela biblioteca
padrão que você não tem certeza do que ele faz, use a documentação da API para
descobrir!</p>
<a class="header" href="print.html#olá-mundo" id="olá-mundo"><h2>Olá, Mundo!</h2></a>
<p>Agora que Rust já está instalado, vamos escrever nosso primeiro programa. Quando
aprendemos uma nova linguagem de programação, é tradicional escrever um pequeno
programa que imprime &quot;Olá, mundo!&quot; (<em>“Hello, world!”</em>) na tela, e é exatamente
isso que vamos fazer nesta seção.</p>
<blockquote>
<p>Nota: Este livro assume que o leitor tem um pouco de familiaridade com a
linha de comando. Rust não exige que você use um determinado editor ou IDE,
ou seja, você está livre para usar o que bem entender para escrever seu código
Rust.</p>
</blockquote>
<a class="header" href="print.html#criando-um-diretório-de-projeto" id="criando-um-diretório-de-projeto"><h3>Criando um Diretório de Projeto</h3></a>
<p>Primeiramente, crie uma pasta para colocar o seu código Rust. O Rust não se
importa onde você vai armazenar o seu código, mas neste livro, nós sugerimos
criar um diretório chamado <em>projetos</em> e armazenar todos os seus projetos ali.
Abra o seu terminal e digite os seguintes comandos:</p>
<p>Linux e Mac:</p>
<pre><code class="language-text">$ mkdir ~/projetos
$ cd ~/projetos
$ mkdir ola_mundo
$ cd ola_mundo
</code></pre>
<p>Windows CMD:</p>
<pre><code class="language-cmd">&gt; mkdir %USERPROFILE%\projetos
&gt; cd %USERPROFILE%\projetos
&gt; mkdir ola_mundo
&gt; cd ola_mundo
</code></pre>
<p>Windows PowerShell:</p>
<pre><code class="language-powershell">&gt; mkdir $env:USERPROFILE\projetos
&gt; cd $env:USERPROFILE\projetos
&gt; mkdir ola_mundo
&gt; cd ola_mundo
</code></pre>
<a class="header" href="print.html#escrevendo-e-executando-um-programa-em-rust" id="escrevendo-e-executando-um-programa-em-rust"><h3>Escrevendo e Executando um Programa em Rust</h3></a>
<p>Crie um novo arquivo <em>main.rs</em>. Arquivos relacionados à linguagem Rust sempre
terminam com a extensão <em>.rs</em>. Se o nome do seu arquivo tem mais de uma palavra,
use um <em>underscore</em> (<code>_</code>) para separá-los. Por exemplo, você deve nomear o seu
arquivo <em>ola_mundo.rs</em> em vez de <em>olamundo.rs</em>.</p>
<p>Agora abra o arquivo <em>main.rs</em> que você acabou de criar e digite o seguinte
código:</p>
<p><span class="filename">Arquivo: main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Olá, mundo!&quot;);
}
</code></pre></pre>
<p>Salve o arquivo e volte ao seu terminal. No Linux ou OSX, digite os seguintes
comandos:</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
Olá, mundo!
</code></pre>
<p>Para executar o seu programa no Windows, digite <code>.\main.exe</code> em vez de <code>./main</code>.
Independente do seu sistema operacional, você deverá ver a mensagem
<code>Olá, mundo!</code> no seu terminal. Se você chegou até aqui, parabéns! Você escreveu
o seu primeiro programa em Rust. Isso faz de você um programador Rust! Seja
bem-vindo!</p>
<a class="header" href="print.html#anatomia-de-um-programa-em-rust" id="anatomia-de-um-programa-em-rust"><h3>Anatomia de um Programa em Rust</h3></a>
<p>Agora vamos ver o que aconteceu com o seu programa &quot;Olá, mundo!&quot; em detalhes.
Aqui está a primeira peça do quebra-cabeça:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>Estas linhas definem uma <em>função</em> em Rust. A função <code>main</code> é especial: é a
primeira coisa que é executada em cada programa escrito em Rust. A primeira
linha diz: &quot;Estou declarando uma função chamada <code>main</code> que não contém nenhum
parâmetro e que não retorna nada.&quot; Se existissem parâmetros, eles estariam
dentro dos parênteses, <code>(</code> e <code>)</code>.</p>
<p>Também repare que o corpo da função está envolvido por duas chaves, <code>{</code> e <code>}</code>.
Rust requer essas chaves no começo e no fim do corpo de cada função.
Considera-se boa prática colocar a chave inicial na mesma linha da declaração
da função, com um espaço entre elas.</p>
<p>Dentro da função <code>main</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;Olá, mundo!&quot;);
#}</code></pre></pre>
<p>Esta linha faz todo o trabalho nesse pequeno programa: imprime um texto na tela.
Existem alguns detalhes a se notar aqui. O primeiro é que o estilo de indentação
do Rust usa quatro espaços, e não um <em>tab</em>.</p>
<p>A segunda parte importante é o <code>println!</code>. Este comando está chamando uma
<em>macro</em>, que é a forma de se fazer metaprogramação em Rust. Se estivéssemos
chamando uma função, ficaria assim: <code>println</code> (sem o <code>!</code>). Vamos discutir
<em>macros</em> em Rust com mais detalhes no Apêndice D, mas por agora, você só precisa
saber que quando usamos um <code>!</code>, significa que estamos chamando uma <em>macro</em> em
vez de uma função.</p>
<p>Em seguida vem <code>&quot;Olá, mundo!&quot;</code>, que é uma <em>string</em>. Nós passamos esta <em>string</em>
como um argumento para a <em>macro</em> <code>println!</code>, que por sua vez imprime a <em>string</em>
na tela. Fácil!</p>
<p>A linha termina com um ponto e vírgula (<code>;</code>). O <code>;</code> indica que esta expressão
acabou, e que a próxima está pronta para começar. A maioria das linhas de código
em Rust terminam com um <code>;</code>.</p>
<a class="header" href="print.html#compilação-e-execução-são-etapas-diferentes" id="compilação-e-execução-são-etapas-diferentes"><h3>Compilação e Execução São Etapas Diferentes</h3></a>
<p>Na seção &quot;Escrevendo e Executando um Programa em Rust&quot;, mostramos como você pode
executar um programa que você acabou de criar. A partir de agora, vamos dividir
este processo em partes e examinar cada uma delas.</p>
<p>Antes de executar qualquer programa em Rust, você deve compilá-lo. Você pode
usar o compilador do Rust utilizando o comando <code>rustc</code>, passando o nome do seu
arquivo fonte conforme o exemplo abaixo:</p>
<pre><code class="language-text">$ rustc main.rs
</code></pre>
<p>Se você já programou em C ou C++, irá notar que esta etapa é bem similar ao uso
do <code>gcc</code> ou <code>clang</code>. Após a compilação ser realizada com sucesso, o Rust deve
gerar como saída um binário executável, que você pode conferir com o comando
<code>ls</code> no seu terminal, se estiver em um ambiente Linux ou OSX:</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<p>No Windows, digite o seguinte:</p>
<pre><code class="language-cmd">&gt; dir /B %= a opção /B serve para mostrar apenas nomes de arquivos =%
main.exe
main.rs
</code></pre>
<p>Temos aqui dois arquivos: o código-fonte, que termina com a extensão <em>.rs</em>, e o
arquivo executável (<em>main.exe</em> no Windows, <em>main</em> nos demais sistemas). O que
nos resta fazer é executar o arquivo <em>main</em> ou <em>main.exe</em>, desta forma:</p>
<pre><code class="language-text">$ ./main  # ou .\main.exe no Windows
</code></pre>
<p>Se o arquivo <em>main.rs</em> tiver o código do programa &quot;Olá, mundo!&quot;, vai aparecer no
seu terminal a mensagem <code>Olá, mundo!</code>.</p>
<p>Se você vem de uma linguagem dinâmica como Ruby, Python, ou JavaScript, você
provavelmente não está acostumado a ver a compilação e a execução como etapas
separadas. Rust é uma linguagem <em>ahead-of-time compiled</em>, isso significa que
você pode compilar um programa, enviá-lo para alguém, e essa pessoa pode
executar o seu programa mesmo que não tenha o Rust instalado em seu ambiente. Se
você enviar a alguém um arquivo <code>.rb</code>, <code>.py</code>, ou <code>.js</code>, a pessoa vai precisar
ter instalado um interpretador Ruby, Python, ou JavaScript (respectivamente),
mas nesse caso você só precisa de um único comando para compilar e executar o
seu programa. Em design de linguagens de programação, tudo é uma relação de
compromisso.</p>
<p>Compilar usando <code>rustc</code> serve bem para programas simples, mas conforme o seu
projeto cresce, com certeza você vai querer gerenciar todas as opções possíveis
para o seu projeto e compartilhar facilmente o seu código com outras pessoas e
projetos. Na sequência, vamos lhe apresentar uma ferramenta chamada Cargo, que
ajuda a escrever programas em Rust usados no mundo real.</p>
<a class="header" href="print.html#olá-cargo" id="olá-cargo"><h2>Olá, Cargo!</h2></a>
<p>Cargo é o sistema de <em>build</em> e gerenciador de pacotes (<em>package manager</em>) do
Rust. Nós, Rustaceans, usamos Cargo para gerenciar nossos projetos em Rust
porque ele facilita muito as coisas. Por exemplo, Cargo se encarrega do processo
de <em>build</em> do seu código, baixa as bibliotecas das quais seu código depende e
compila essas bibliotecas. As bibliotecas necessárias ao seu código nós chamamos
de <em>dependências</em>.</p>
<p>Programas simples em Rust, como o que escrevemos a pouco, não têm nenhuma
dependência, então por enquanto, você só vai usar a parte do Cargo que cuida do
<em>build</em> do seu código. À medida que você escrever programas mais complexos em
Rust, você vai querer adicionar dependências, e utilizando o Cargo, será bem
mais fácil fazer isso.</p>
<p>Como a vasta maioria dos projetos em Rust usam Cargo, vamos assumir que você vai
usá-lo pelo resto do livro. O Cargo já vem instalado com o próprio Rust, se você
utilizou algum dos instaladores oficiais abordados na seção sobre instalação. Se
você utilizou outros meios para instalar Rust, você pode verificar se tem o
Cargo instalado digitando o seguinte comando no seu terminal:</p>
<pre><code class="language-text">$ cargo --version
</code></pre>
<p>Se aparecer um número de versão, ótimo! Mas, se aparecer um erro como <code>command not found</code>, você deve olhar a documentação do método de instalação utilizado,
para verificar como instalar Cargo em seu ambiente.</p>
<a class="header" href="print.html#criando-um-projeto-com-cargo" id="criando-um-projeto-com-cargo"><h3>Criando um Projeto com Cargo</h3></a>
<p>Vamos criar um novo projeto usando Cargo e ver o que muda em relação ao nosso
primeiro projeto <code>ola_mundo</code>. Volte ao seu diretório de projetos (ou aonde quer
que você tenha colocado o seu código):</p>
<p>Linux e Mac:</p>
<pre><code class="language-text">$ cd ~/projetos
</code></pre>
<p>Windows:</p>
<pre><code class="language-cmd">&gt; cd %USERPROFILE%\projetos
</code></pre>
<p>E então execute o comando abaixo:</p>
<pre><code class="language-text">$ cargo new ola_cargo --bin
$ cd ola_cargo
</code></pre>
<p>Passamos o argumento <code>--bin</code> para o comando <code>cargo new</code> porque o nosso objetivo
é fazer uma aplicação executável, em vez de uma biblioteca. Executáveis são
arquivos binários, muitas vezes chamados apenas de <em>binários</em>. Demos o nome
<code>ola_cargo</code> ao nosso projeto, e o Cargo já criou os arquivos dele em uma nova
pasta com o mesmo nome, que agora podemos acessar.</p>
<p>Se listarmos os arquivos na pasta <em>ola_cargo</em>, podemos ver que o Cargo gerou
dois arquivos e um diretório para nós: um arquivo <em>Cargo.toml</em> e um diretório
<em>src</em>, com um arquivo <em>main.rs</em> dentro dele. Também automaticamente já
inicializou um repositório git na pasta <em>ola_cargo</em>, junto com um arquivo
<em>.gitignore</em>. Você pode mudar isso se quiser usar um sistema de controle de
versão diferente, ou se não quiser usar nenhum. Basta usar a flag <code>--vcs</code>.</p>
<p>Abra o arquivo <em>Cargo.toml</em> no seu editor de texto. O conteúdo dele é algo
assim:</p>
<p><span class="filename">Arquivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;ola_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Seu Nome &lt;voce@exemplo.com&gt;&quot;]

[dependencies]
</code></pre>
<p>Este arquivo está no formato <a href="https://github.com/toml-lang/toml"><em>TOML</em></a><!-- ignore --> (<em>Tom’s Obvious,
Minimal Language</em>). TOML é similar a INI com algumas coisinhas a mais e é
usado como formato de configuração do Cargo.</p>
<p>A primeira linha, <code>[package]</code>, é um cabeçalho de seção que indica que o que vem
em seguida está configurando um pacote. Ao passo que adicionamos mais
informações a este arquivo, vamos adicionar outras seções a ele.</p>
<p>As próximas três linhas indicam as três configurações de que o Cargo precisa
para saber como compilar o seu programa: nome, versão, e o autor. O Cargo
consegue o seu nome e <em>e-mail</em> através do seu ambiente. Se não estiver correto,
corrija e depois salve o arquivo.</p>
<p>A última linha, <code>[dependencies]</code>, é o começo da seção em que você deve listar
quaisquer <em>crates</em> (como chamamos os pacotes de código em Rust) das quais o seu
projeto irá depender, assim o Cargo sabe que deve baixar e compilar estes
pacotes também. Não vamos precisar de nenhum <em>crate</em> para este projeto, mas sim
para o projeto do jogo de advinhação que faremos no próximo capítulo.</p>
<p>Agora vamos dar uma olhada em <em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>O Cargo gerou um &quot;Olá, mundo!&quot; para você, igual ao que escrevemos anteriormente
(porém em inglês)! Esta parte é a mesma. As diferenças entre o nosso projeto
anterior e o projeto gerado pelo Cargo, que vimos até agora, foram:</p>
<ul>
<li>Nosso código fica dentro do diretório <em>src</em></li>
<li>A pasta raiz do nosso projeto contém um arquivo de configuração <em>Cargo.toml</em></li>
</ul>
<p>O Cargo espera que os seus arquivos de código fiquem no diretório <em>src</em>, de
maneira que a pasta raiz seja apenas para <em>READMEs</em>, informações a respeito de
licença, arquivos de configuração, e tudo mais que não for relacionado a código.
Assim, o uso de Cargo lhe ajuda a manter os seus projetos bem organizados. Há um
lugar pra cada coisa, e cada coisa fica em seu lugar.</p>
<p>Se você iniciou um projeto que não usa Cargo, como fizemos com nosso projeto na
pasta <em>ola_mundo</em>, você pode convertê-lo em um projeto que usa o Cargo. Basta
mover o seu código para um diretório <em>src</em> e criar um arquivo <em>Cargo.toml</em>.</p>
<a class="header" href="print.html#realizando-o-build-e-executando-um-projeto-cargo" id="realizando-o-build-e-executando-um-projeto-cargo"><h3>Realizando o Build e Executando um projeto Cargo</h3></a>
<p>Agora vamos ver o que muda ao compilar e executar o seu projeto &quot;Olá, Mundo!&quot;
através do Cargo! Para isso, digite os seguintes comandos:</p>
<pre><code class="language-text">$ cargo build
   Compiling ola_cargo v0.1.0 (file:///projetos/ola_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>Este comando deve criar um arquivo executável em <em>target/debug/ola_cargo</em> (ou
<em>target\debug\ola_cargo.exe</em> no Windows), que você pode executar com o seguinte
comando:</p>
<pre><code class="language-text">$ ./target/debug/ola_cargo # ou .\target\debug\ola_cargo.exe no Windows
Hello, world!
</code></pre>
<p>Bam! Se tudo ocorrer bem, a mensagem <code>Hello, world!</code> deve aparecer no seu terminal.</p>
<p>Executar <code>cargo build</code> pela primeira vez também faz com que Cargo crie um novo
arquivo chamado <em>Cargo.lock</em>, com um conteúdo desse tipo:</p>
<p><span class="filename">Arquivo: Cargo.lock</span></p>
<pre><code class="language-toml">[root]
name = &quot;ola_cargo&quot;
version = &quot;0.1.0&quot;
</code></pre>
<p>O Cargo usa o arquivo <em>Cargo.lock</em> para rastrear as dependências da sua
aplicação. Este projeto não tem dependências, então o arquivo é um pouco
escasso. Na realidade, você nem vai precisar mexer neste arquivo, apenas deixe
que o Cargo se encarregue dele.</p>
<p>Nós acabamos de fazer o <em>build</em> de um projeto utilizando o comando
<code>cargo build</code>, e o executamos com o comando <code>./target/debug/ola_cargo</code>, mas
podemos usar também o comando <code>cargo run</code> para compilar e executar em sequência:</p>
<pre><code class="language-text">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/ola_cargo`
Hello, world!
</code></pre>
<p>Repare que, desta vez, não vimos nenhuma mensagem de <em>output</em> (saída) nos
dizendo que Cargo estava compilando <code>ola_cargo</code>. O Cargo entendeu que não houve
nenhuma mudança nos arquivos, então ele apenas executou o binário. Se você
tivesse modificado o seu código-fonte, o Cargo teria recompilado o projeto antes
de executá-lo, e você teria visto algo do tipo:</p>
<pre><code class="language-text">$ cargo run
   Compiling ola_cargo v0.1.0 (file:///projetos/ola_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/ola_cargo`
Hello, world!
</code></pre>
<p>Então, mais algumas diferenças que vimos até agora foram:</p>
<ul>
<li>Em vez de usar <code>rustc</code>, faça o <em>build</em> do projeto usando <code>cargo build</code> (ou
faça o build e execute de uma vez só utilizando <code>cargo run</code>)</li>
<li>Em vez de colocar o resultado do <em>build</em> no mesmo diretório do nosso código, o
Cargo irá colocar o resultado do <em>build</em> no diretório <em>target/debug</em>.</li>
</ul>
<p>A outra vantagem de usar o Cargo é que os comandos são os mesmos, não importa em
qual sistema operacional você esteja. Por conta disso, a partir de agora, não
vamos mais fornecer instruções específicas para Linux e Mac ou Windows.</p>
<a class="header" href="print.html#compilando-para-release" id="compilando-para-release"><h3>Compilando para <em>Release</em></h3></a>
<p>Quando o seu projeto está finalmente pronto para ser lançado, você pode usar o
comando <code>cargo build --release</code> para compilar o seu projeto com otimizações.
Isso vai criar um arquivo executável na pasta <em>target/release</em> em vez de
<em>target/debug</em>. Estas otimizações fazem o seu código Rust executar de maneira
mais rápida, mas por outro lado, também fazem o programa levar mais tempo para
compilar. Por isso existem dois perfis diferentes: um para desenvolvimento,
quando você deseja recompilar rapidamente e com mais frequência, e outro para
compilar a versão final do seu programa, que vai ser entregue ao usuário e não
será recompilada, e queremos que rode da maneira mais rápida possível. Se você
está fazendo um <em>benchmarking</em> do tempo de execução do seu código, certifique-se
de executar o comando <code>cargo build --release</code>, e usar o executável que se
encontra na pasta <em>target/release</em>.</p>
<a class="header" href="print.html#cargo-como-convenção" id="cargo-como-convenção"><h3>Cargo como Convenção</h3></a>
<p>Em projetos simples, o Cargo não oferece tanto valor assim em relação a usar
apenas o <code>rustc</code>, mas vai fazer diferença à medida que você continua. Em
projetos mais complexos, compostos de múltiplos <em>crates</em>, é bem mais fácil
deixar o Cargo coordenar o processo de <em>build</em>. Com o Cargo, você pode apenas
executar o comando <code>cargo build</code>, e tudo deverá funcionar da maneira correta.
Mesmo esse projeto sendo simples, ele utiliza muito das ferramentas que você
irá usar pelo resto da sua carreira em Rust. Na verdade, você pode começar a
trabalhar em praticamente qualquer projeto em Rust usando os seguintes comandos:</p>
<pre><code class="language-text">$ git clone algumaurl.com/algumprojeto
$ cd algumprojeto
$ cargo build
</code></pre>
<blockquote>
<p>Nota: Se você deseja conhecer o Cargo em mais detalhes, confira o
<a href="http://doc.crates.io/guide.html">Guia oficial do Cargo</a><!-- ignore --> (em inglês), que aborda todas as suas
características.</p>
</blockquote>
<a class="header" href="print.html#jogo-de-adivinhação" id="jogo-de-adivinhação"><h1>Jogo de Adivinhação</h1></a>
<p>Vamos entrar de cabeça no Rust e colocar a mão na massa! Este capítulo vai lhe
apresentar alguns conceitos bem comuns no Rust, mostrando como usá-los em um
programa de verdade. Você vai aprender sobre <code>let</code>, <code>match</code>, métodos, funções
associadas, crates externos, e mais! Os capítulos seguintes vão explorar essas
ideias em mais detalhes. Neste capítulo, você vai praticar o básico.</p>
<p>Vamos implementar um clássico problema de programação para iniciantes: um jogo
de adivinhação. Eis como ele funciona: o programa vai gerar um número inteiro
aleatório entre 1 e 100. Então, ele vai pedir ao jogador que digite um palpite.
Após darmos nosso palpite, ele vai nos indicar se o palpite é muito baixo ou
muito alto. Uma vez que o palpite estiver correto, ele vai nos dar os parabéns e
sair.</p>
<a class="header" href="print.html#preparando-um-novo-projeto" id="preparando-um-novo-projeto"><h2>Preparando um Novo Projeto</h2></a>
<p>Para iniciar um novo projeto, vá ao seu diretório de projetos que você criou no
Capítulo 1, e execute os comandos do Cargo a seguir:</p>
<pre><code class="language-text">$ cargo new jogo_de_advinhacao --bin
$ cd jogo_de_advinhacao
</code></pre>
<p>O primeiro comando, <code>cargo new</code>, recebe o nome do projeto (<code>jogo_de_advinhacao</code>)
como primeiro argumento. A flag <code>--bin</code> diz ao Cargo que faça um projeto
binário, similar ao do Capítulo 1. O segundo comando muda a pasta atual para o
diretório do projeto.</p>
<p>Confira o arquivo <em>Cargo.toml</em> gerado:</p>
<p><span class="filename">Arquivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;jogo_de_advinhacao&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Seu Nome &lt;voce@exemplo.com&gt;&quot;]

[dependencies]
</code></pre>
<p>Se as informações sobre o autor, que o Cargo obtém do seu ambiente, não
estiverem corretas, faça os reparos necessários e salve o arquivo.</p>
<p>Assim como no Capítulo 1, <code>cargo new</code> gera um programa &quot;Hello, world!&quot; para nós.
Confira em <em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Agora vamos compilar esse programa &quot;Hello, world!&quot; e executá-lo de uma vez só
usando o comando <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/jogo_de_advinhacao`
Hello, world!
</code></pre>
<p>O comando <code>run</code> é uma boa opção quando precisamos iterar rapidamente em um
projeto, que é o caso neste jogo: nós queremos testar rapidamente cada iteração
antes de movermos para a próxima.</p>
<p>Abra novamente o arquivo <em>src/main.rs</em>. Escreveremos todo nosso código nele.</p>
<a class="header" href="print.html#processando-um-palpite" id="processando-um-palpite"><h2>Processando um Palpite</h2></a>
<p>A primeira parte do programa vai pedir uma entrada ao usuário, processar essa
entrada, e conferir se ela está no formato esperado. Pra começar, vamos permitir
que o jogador entre com um palpite. Coloque este código no arquivo
<em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Advinhe o número!&quot;);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;Você disse: {}&quot;, palpite);
}
</code></pre>
<p><span class="caption">Listagem 2-1: Código para ler um palpite do usuário e
imprimí-lo na tela.</span></p>
<p>Esse código tem muita informação, vamos ver uma parte de cada vez. Para obter a
entrada do usuário, e então imprimir o resultado como saída, precisaremos trazer
ao escopo a biblioteca <code>io</code> (de entrada/saída). A biblioteca <code>io</code> provém da
biblioteca padrão (chamada de <code>std</code>):</p>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<p>Por padrão, o Rust traz apenas alguns tipos para o escopo de todos os programas
no <a href="../../std/prelude/index.html"><em>prelúdio</em></a><!-- ignore -->. Se um tipo que você quiser usar não
estiver no prelúdio, você terá que importá-lo explicitamente através do <code>use</code>.
A biblioteca <code>std::io</code> oferece várias ferramentas de entrada/saída, incluindo a
funcionalidade de ler dados de entrada do usuário.</p>
<p>Como visto no Capítulo 1, a função <code>main</code> é o ponto de entrada do programa:</p>
<pre><code class="language-rust ignore">fn main() {
</code></pre>
<p>A sintaxe <code>fn</code> declara uma nova função, o <code>()</code> indica que não há parâmetros, e
o <code>{</code> inicia o corpo da função.</p>
<p>Como você também já aprendeu no Capítulo 1, <code>println!</code> é uma macro que imprime
uma string na tela:</p>
<pre><code class="language-rust ignore">println!(&quot;Advinhe o número!&quot;);

println!(&quot;Digite o seu palpite.&quot;);
</code></pre>
<p>Este código está exibindo uma mensagem que diz de que se trata o jogo e solicita
uma entrada do usuário.</p>
<a class="header" href="print.html#armazenando-valores-em-variáveis" id="armazenando-valores-em-variáveis"><h3>Armazenando Valores em Variáveis</h3></a>
<p>Próximo passo, vamos criar um local para armazenar a entrada do usuário:</p>
<pre><code class="language-rust ignore">let mut palpite = String::new();
</code></pre>
<p>Agora o programa está ficando interessante! Tem muita coisa acontecendo nesta
pequena linha. Repare que esta é uma declaração <code>let</code>, que é usada para criar
<em>variáveis</em>. Segue outro exemplo:</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<p>Essa linha cria uma nova variável chamada <code>foo</code>, e a vincula ao valor <code>bar</code>. Em
Rust, variáveis são imutáveis por padrão. O exemplo a seguir mostra como usar
<code>mut</code> antes do nome da variável para torná-la mutável:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let foo = 5; // imutável
let mut bar = 5; // mutável
#}</code></pre></pre>
<blockquote>
<p>Nota: A sintaxe <code>//</code> inicia um comentário, que continua até o fim da linha.
Rust ignora tudo o que estiver nos comentários.</p>
</blockquote>
<p>Agora você sabe que <code>let mut palpite</code> vai introduzir uma variável mutável de
nome <code>palpite</code>. No outro lado do símbolo <code>=</code> está o valor ao qual <code>palpite</code> está
vinculado, que é o resultado da chamada <code>String::new</code>, uma função que retorna
uma nova instância de <code>String</code>. <a href="../../std/string/struct.String.html"><code>String</code></a><!-- ignore --> é um tipo
fornecido pela biblioteca padrão que representa uma cadeia expansível de
caracteres codificados em UTF-8.</p>
<p>A sintaxe <code>::</code> na linha <code>::new</code> indica que <code>new</code> é uma <em>função associada</em> do
tipo <code>String</code>. Uma função associada é implementada sobre um tipo, neste caso
<code>String</code>, em vez de uma instância particular de <code>String</code>. Algumas linguagens
dão a isso o nome <em>método estático</em>.</p>
<p>Esta função <code>new()</code> cria uma nova <code>String</code> vazia. Você encontrará uma função
<code>new()</code> em muitos tipos, já que é um nome comum para uma função que produz um
novo valor de algum tipo.</p>
<p>Para resumir, a linha <code>let mut palpite = String::new();</code> criou uma variável
mutável que está atualmente vinculada a uma nova instância vazia de uma
<code>String</code>. Ufa!</p>
<p>Lembre-se de que incluímos a funcionalidade de entrada/saída da biblioteca
padrão por meio do <code>use std::io;</code> na primeira linha do programa. Agora vamos
chamar uma função associada, <code>stdin</code>, em <code>io</code>:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut palpite)
    .expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>Se não tivéssemos a linha <code>use std::io</code> no início do programa, poderíamos ter
escrito esta chamada como <code>std::io::stdin</code>. A função <code>stdin</code> retorna uma
instância de <a href="../../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, um tipo que representa
um manipulador (<em>handle</em>) da entrada padrão do seu terminal.</p>
<p>A próxima parte do código, <code>.read_line(&amp;mut palpite)</code>, chama o método
<a href="../../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> do <em>handle</em> da entrada padrão para obter
entrada do usuário. Também estamos passando um argumento para <code>read_line</code>:
<code>&amp;mut palpite</code>.</p>
<p>O trabalho da função <code>read_line</code> é receber o que o usuário digita na entrada
padrão e colocar isso numa string, por isso ela recebe essa string como
argumento. A string do argumento deve ser mutável para que o método consiga
alterar o seu conteúdo, adicionando a entrada do usuário.</p>
<p>O símbolo <code>&amp;</code> indica que o argumento é uma <em>referência</em>, o que permite múltiplas
partes do seu código acessar um certo dado sem precisar criar várias cópias dele
na memória. Referências são uma característica complexa, e uma das maiores
vantagens do Rust é o quão fácil e seguro é usar referências. Você não precisa
conhecer muitos desses detalhes para finalizar esse programa. O Capítulo 4 vai
explicar sobre referências de forma mais aprofundada. Por enquanto, tudo que
você precisa saber é que, assim como as variáveis, referências são imutáveis por
padrão. Por isso, precisamos escrever <code>&amp;mut palpite</code>, em vez de apenas
<code>&amp;palpite</code>, para fazer com que o palpite seja mutável.</p>
<p>Ainda não finalizamos completamente esta linha de código. Embora esta seja uma
única linha de texto, é apenas a primeira parte de uma linha lógica de código. A
segunda parte é a chamada para este método:</p>
<pre><code class="language-rust ignore">.expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>Quando você chama um método com a sintaxe <code>.foo()</code>, geralmente é bom introduzir
uma nova linha e outro espaço para ajudar a dividir linhas muito compridas.
Poderíamos ter feito assim:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut palpite).expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>Porém, uma linha muito comprida fica difícil de ler. Então é melhor dividirmos a
linha em duas, uma para cada método chamado. Agora vamos falar sobre o que essa
linha faz.</p>
<a class="header" href="print.html#tratando-potenciais-falhas-com-o-tipo-result" id="tratando-potenciais-falhas-com-o-tipo-result"><h3>Tratando Potenciais Falhas com o Tipo <code>Result</code></h3></a>
<p>Como mencionado anteriormente, <code>read_line</code> coloca o que o usuário escreve dentro
da string que passamos como argumento, mas também retorna um valor - neste
caso, um <a href="../../std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->. Rust tem uma variedade de
tipos com o nome <code>Result</code> em sua biblioteca padrão: um <a href="../../std/result/enum.Result.html"><code>Result</code></a>
genérico e as versões específicas dos submódulos, como <code>io::Result</code>.</p>
<p>Os tipos <code>Result</code> são <a href="ch06-00-enums.html"><em>enumerações</em></a><!-- ignore -->, comumente chamadas
de <em>enums</em>. Uma enumeração é um tipo que pode ter um conjunto fixo de valores,
os quais são chamados de <em>variantes</em> da enum. O Capítulo 6 vai abordar enums em
mais detalhes.</p>
<p>Para <code>Result</code>, as variantes são <code>Ok</code> ou <code>Err</code>. <code>Ok</code> indica que a operação teve
sucesso, e dentro da variante <code>Ok</code> está o valor resultante. <code>Err</code> significa que
a operação falhou, e contém informações sobre como ou por que isso ocorreu.</p>
<p>O propósito destes tipos <code>Result</code> é codificar informações de manipulação de
erros. Valores do tipo <code>Result</code>, assim como qualquer tipo, possuem métodos
definidos. Uma instância de <code>io::Result</code> tem um <a href="../../std/result/enum.Result.html#method.expect">método <code>expect</code></a><!-- ignore -->
que você pode chamar. Se esta instância de <code>io::Result</code> é um <code>Err</code>, <code>expect</code> vai
terminar o programa com erro e mostrar a mensagem que você passou como argumento
ao <code>expect</code>. Se o método <code>read_line</code> retornar um <code>Err</code>, provavelmente seria o
resultado de um erro vindo do sistema operacional que está por trás. Se esta
instância de <code>io::Result</code> é um <code>Ok</code>, <code>expect</code> vai obter o valor contido no <code>Ok</code>
e retorná-lo para que você possa usá-lo. Neste caso, o valor é o número de bytes
dos dados que o usuário inseriu através da entrada padrão.</p>
<p>Se não chamarmos <code>expect</code>, nosso programa vai compilar, mas vamos ter um aviso:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
warning: unused `std::result::Result` which must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut palpite);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default
</code></pre>
<p>Rust avisa que não usamos o valor <code>Result</code>, retornado por <code>read_line</code>, indicando
que o programa deixou de tratar um possível erro. A maneira correta de suprimir
o aviso é realmente escrevendo um tratador de erro, mas como queremos que o
programa seja encerrado caso ocorra um problema, podemos usar <code>expect</code>. Você
aprenderá sobre recuperação de erros no Capítulo 9.</p>
<a class="header" href="print.html#exibindo-valores-com-curingas-do-println" id="exibindo-valores-com-curingas-do-println"><h3>Exibindo Valores com Curingas do <code>println!</code></h3></a>
<p>Tirando a chave que delimita a função <code>main</code>, há apenas uma linha mais a ser
discutida no código que fizemos até agora, que é a seguinte:</p>
<pre><code class="language-rust ignore">println!(&quot;Você disse: {}&quot;, guess);
</code></pre>
<p>Esta linha imprime a string na qual salvamos os dados inseridos pelo usuário. O
<code>{}</code> é um curinga que reserva o lugar de um valor. Você pode imprimir mais de um
valor usando <code>{}</code>: o primeiro conjunto de <code>{}</code> guarda o primeiro valor listado
após a string de formatação, o segundo conjunto guarda o segundo valor, e
assim por diante. Imprimir múltiplos valores em uma só chamada a <code>println!</code>
seria assim:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = 10;

println!(&quot;x = {} e y = {}&quot;, x, y);
#}</code></pre></pre>
<p>Esse código imprime <code>x = 5 e y = 10</code>.</p>
<a class="header" href="print.html#testando-a-primeira-parte" id="testando-a-primeira-parte"><h3>Testando a Primeira Parte</h3></a>
<p>Vamos testar a primeira parte do jogo de advinhação. Você pode executá-lo usando
<code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/jogo_de_advinhacao`
Advinhe o número!
Digite o seu palpite.
6
Você disse: 6
</code></pre>
<p>Nesse ponto, a primeira parte do jogo está feita: podemos coletar entrada do
teclado e mostrá-la na tela.</p>
<a class="header" href="print.html#gerando-um-número-secreto" id="gerando-um-número-secreto"><h2>Gerando um Número Secreto</h2></a>
<p>A seguir, precisamos gerar um número secreto que o usuário vai tentar advinhar.
O número secreto deve ser diferente a cada execução, para que o jogo tenha graça
em ser jogado mais de uma vez. Vamos usar um número aleatório entre 1 e 100,
para que o jogo não seja tão difícil. Rust ainda não inclui uma funcionalidade
de geração de números aleatórios em sua biblioteca padrão. Porém, a equipe Rust
fornece um <a href="https://crates.io/crates/rand">crate <code>rand</code></a>.</p>
<a class="header" href="print.html#usando-um-crate-para-ter-mais-funcionalidades" id="usando-um-crate-para-ter-mais-funcionalidades"><h3>Usando um Crate para Ter Mais Funcionalidades</h3></a>
<p>Lembre-se que um <em>crate</em> é um pacote de código Rust. O projeto que estamos
construindo é um <em>crate binário</em>, que é um executável. Já o <code>rand</code> é um
<em>crate de biblioteca</em>, que contém código cujo objetivo é ser usado por outros
programas.</p>
<p>É no uso de crates externos que Cargo realmente brilha. Antes que possamos
escrever o código usando <code>rand</code>, precisamos modificar o arquivo <em>Cargo.toml</em>
para incluir o crate <code>rand</code> como uma dependência. Abra o arquivo e adicione
esta linha no final, abaixo do cabeçalho da seção <code>[dependencies]</code> que o Cargo
criou para você:</p>
<p><span class="filename">Arquivo: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p>No arquivo <em>Cargo.toml</em>, tudo que vem depois de um cabeçalho é parte de uma
seção que segue até o início de outra. A seção <code>[dependencies]</code> é onde você diz
ao Cargo de quais crates externos o seu projeto depende, e quais versões desses
crates você exige. Neste caso, especificamos o crate <code>rand</code> com a versão
semântica <code>0.3.14</code>. Cargo compreende <a href="https://semver.org/lang/pt-BR/">Versionamento Semântico</a><!-- ignore -->
(às vezes chamado <em>SemVer</em>), um padrão para escrever números de versões. O
número <code>0.3.14</code> é, na verdade, uma forma curta de escrever <code>^0.3.14</code>, que
significa &quot;qualquer versão que tenha uma API pública compatível com a versão
0.3.14&quot;.</p>
<p>Agora, sem mudar código algum, vamos compilar nosso projeto, conforme mostrado
na Listagem 2-2:</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
 Downloading libc v0.2.14
   Compiling libc v0.2.14
   Compiling rand v0.3.14
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p><span class="caption">Listagem 2-2: Resultado da execução de <code>cargo build</code>
depois de adicionar o crate <code>rand</code> como dependência.</span></p>
<p>Talvez pra você apareçam versões diferentes (mas elas são todas compatíveis com
o código, graças ao Versionamento Semântico!), e as linhas talvez apareçam em
ordem diferente.</p>
<p>Agora que temos uma dependência externa, Cargo busca as versões mais recentes de
tudo no <em>registro</em>, que é uma cópia dos dados do <a href="https://crates.io">Crates.io</a>.
Crates.io é onde as pessoas do ecossistema Rust postam seus projetos
<em>open source</em> para que os outros possam usar.</p>
<p>Após atualizar o registro, Cargo verifica a seção <code>[dependencies]</code> e baixa todas
as que você não tem ainda. Neste caso, embora tenhamos listado apenas <code>rand</code>
como dependência, o Cargo também puxou uma cópia da <code>libc</code>, porque <code>rand</code>
depende da <code>libc</code> para funcionar. Depois de baixá-las, o Cargo as compila e
então compila nosso projeto.</p>
<p>Se, logo em seguida, você executar <code>cargo build</code> novamente sem fazer mudanças,
não vai aparecer nenhuma mensagem de saída. O Cargo sabe que já baixou e
compilou as dependências, e você não alterou mais nada sobre elas no seu arquivo
<em>Cargo.toml</em>. Cargo também sabe que você não mudou mais nada no seu código, e
por isso não o recompila. Sem nada a fazer, ele simplesmente sai. Se você abrir
<em>src/main.rs</em>, fizer uma modificação trivial, salvar e compilar de novo, vai
aparecer uma mensagem de apenas duas linhas:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Essas linhas mostram que o Cargo só atualiza o <em>build</em> com a sua pequena mudança
no arquivo <em>src/main.rs</em>. Suas dependências não mudaram, então o Cargo sabe que
pode reutilizar o que já tiver sido baixado e compilado para elas. Ele apenas
recompila a sua parte do código.</p>
<a class="header" href="print.html#o-arquivo-cargolock-garante-builds-reproduzíveis" id="o-arquivo-cargolock-garante-builds-reproduzíveis"><h4>O Arquivo <em>Cargo.lock</em> Garante <em>Builds</em> Reproduzíveis</h4></a>
<p>O Cargo tem um mecanismo que assegura que você pode reconstruir o mesmo artefato
toda vez que você ou outra pessoa compilar o seu código. O Cargo vai usar apenas
as versões das dependências que você especificou, até que você indique o
contrário. Por exemplo, o que acontece se, na semana que vem, sair a versão
<code>v0.3.15</code> contendo uma correção de bug, mas também uma regressão que não
funciona com o seu código?</p>
<p>A resposta para isso está no arquivo <em>Cargo.lock</em>, que foi criado na primeira
vez que você executou <code>cargo build</code>, e agora está no seu diretório
<em>jogo_de_advinhacao</em>. Quando você compila o seu projeto pela primeira vez, o
Cargo descobre as versões de todas as dependências que preenchem os critérios
e então as escreve no arquivo <em>Cargo.lock</em>. Quando você compilar o seu projeto
futuramente, o Cargo verá que o arquivo <em>Cargo.lock</em> existe e usará as versões
especificadas lá, em vez de refazer todo o trabalho descobrir as versões
novamente. Isto lhe permite ter um <em>build</em> reproduzível automaticamente. Em
outras palavras, seu projeto vai continuar com a versão <code>0.3.14</code> até que você
faça uma atualização explícita, graças ao arquivo <em>Cargo.lock</em>.</p>
<a class="header" href="print.html#atualizando-um-crate-para-obter-uma-nova-versão" id="atualizando-um-crate-para-obter-uma-nova-versão"><h4>Atualizando um Crate para Obter uma Nova Versão</h4></a>
<p>Quando você <em>quiser</em> atualizar um crate, o Cargo tem outro comando, <code>update</code>,
que faz o seguinte:</p>
<ol>
<li>Ignora o arquivo <em>Cargo.lock</em> e descobre todas as versões mais recentes que
atendem as suas especificações no <em>Cargo.toml</em>.</li>
<li>Se funcionar, o Cargo escreve essas versões no arquivo <em>Cargo.lock</em>.</li>
</ol>
<p>Mas, por padrão, o Cargo vai procurar as versões maiores que <code>0.3.0</code> e menores
que <code>0.4.0</code>. Se o crate <code>rand</code> já tiver lançado duas novas versões, <code>0.3.15</code> e
<code>0.4.0</code>, você verá a seguinte mensagem ao executar <code>cargo update</code>:</p>
<pre><code class="language-text">$ cargo update
    Updating registry `https://github.com/rust-lang/crates.io-index`
    Updating rand v0.3.14 -&gt; v0.3.15
</code></pre>
<p>Nesse ponto, você vai notar também uma mudança no seu arquivo <em>Cargo.lock</em>
dizendo que a versão do crate <code>rand</code> que você está usando agora é a <code>0.3.15</code>.</p>
<p>Se você quisesse usar a versão <code>0.4.0</code>, ou qualquer versão da série <code>0.4.x</code> do
<code>rand</code>, você teria que atualizar o seu <em>Cargo.toml</em> dessa forma:</p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.4.0&quot;
</code></pre>
<p>Na próxima vez que você executar <code>cargo build</code>, o Cargo vai atualizar o registro
de crates disponíveis e reavaliar os seus requisitos sobre o <code>rand</code> de acordo
com a nova versão que você especificou.</p>
<p>Há muito mais a ser dito sobre <a href="http://doc.crates.io">Cargo</a><!-- ignore --> e o <a href="http://doc.crates.io/crates-io.html">seu
ecossistema</a><!-- ignore --> que vai ser discutido no Capítulo 14,
mas por ora isto é tudo que você precisa saber. Cargo facilita muito reutilizar
bibliotecas, de forma que os <em>rustáceos</em> consigam escrever projetos menores que
são montados a partir de diversos pacotes.</p>
<a class="header" href="print.html#gerando-um-número-aleatório" id="gerando-um-número-aleatório"><h3>Gerando um Número Aleatório</h3></a>
<p>Agora vamos <em>usar</em>, de fato, o <code>rand</code>. O próximo passo é atualizar o
<em>src/main.rs</em> conforme mostrado na Listagem 2-3:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o número!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O número secreto é: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;Você disse: {}&quot;, palpite);
}
</code></pre>
<p><span class="caption">Listagem 2-3: Mudanças necessárias do código para gerar um
número aleatório.</span></p>
<p>Estamos adicionando a linha <code>extern crate rand</code> ao topo do arquivo para indicar
ao Rust que estamos usando uma dependência externa. Isto também é equivalente a
um <code>use rand;</code>, assim podemos chamar qualquer coisa que esteja no crate <code>rand</code>
prefixando-a com <code>rand::</code>.</p>
<p>Em seguida, adicionamos outra linha <code>use</code>: <code>use rand::Rng</code>. <code>Rng</code> é um trait
que define métodos a serem implementados pelos geradores de números aleatórios,
e esse trait deve estar dentro do escopo para que possamos usar esses métodos. O
Capítulo 10 vai abordar traits em mais detalhes.</p>
<p>Tem outras duas linhas que adicionamos no meio. A função <code>rand::thread_rng</code> nos
dá o gerador de números aleatórios que vamos usar, um que é local à <em>thread</em>
corrente e que é inicializado pelo sistema operacional. Depois, vamos chamar o
método <code>gen_range</code> no gerador de números aleatórios. Esse método está definido
pelo trait <code>Rng</code> que trouxemos ao escopo por meio do <code>use rand::Rng</code>. Este
método recebe dois argumentos e gera um número aleatório entre eles. Ele inclui
o limite inferior mas exclui o superior, então precisamos passar <code>1</code> e <code>101</code>
para obter um número de 1 a 100.</p>
<p>Saber quais traits devem ser usadas e quais funções e métodos de um crate
devem ser chamados não é nada trivial. As instruções de como usar um crate
estão na documentação de cada um. Outra coisa boa do Cargo é que você pode rodar
o comando <code>cargo doc --open</code> que vai construir localmente a documentação
fornecida por todas as suas dependências e abrí-las no seu navegador. Se você
estiver interessado em outras funcionalidades do crate <code>rand</code>, por exemplo,
execute <code>cargo doc --open</code> e clique em <code>rand</code>, no menu ao lado esquerdo.</p>
<p>A segunda linha que adicionamos imprime o número secreto. Isto é útil enquanto
estamos desenvolvendo o programa para podermos testá-lo, mas vamos retirá-la da
versão final. Um jogo não é muito interessante se ele mostra a resposta logo no
início!</p>
<p>Tente rodar o programa algumas vezes:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/jogo_de_advinhacao`
Advinhe o número!
O número secreto é: 7
Digite o seu palpite.
4
Você disse: 4
$ cargo run
     Running `target/debug/jogo_de_advinhacao`
Advinhe o número!
O número secreto é: 83
Digite o seu palpite.
5
Você disse: 5
</code></pre>
<p>Você já deve obter números aleatórios diferentes, e eles devem ser todos entre 1
e 100. Bom trabalho!</p>
<a class="header" href="print.html#comparando-o-palpite-com-o-número-secreto" id="comparando-o-palpite-com-o-número-secreto"><h2>Comparando o Palpite com o Número Secreto</h2></a>
<p>Agora que nós temos a entrada do usuário e o número secreto, vamos compará-los.
Esta estapa é mostrada na Listagem 2-4:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o número!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O número secreto é: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;Você disse: {}&quot;, palpite);

    match palpite.cmp(&amp;numero_secreto) {
        Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
        Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
        Ordering::Equal =&gt; println!(&quot;Você acertou!&quot;),
    }
}
</code></pre>
<p><span class="caption">Listagem 2-4: Tratando os possíveis resultados da
comparação de dois números.</span></p>
<p>A primeira novidade aqui é outro <code>use</code>, que traz ao escopo um tipo da biblioteca
padrão chamado <code>std::cmp::Ordering</code>. <code>Ordering</code> é outra enum, igual a <code>Result</code>,
mas as suas variantes são <code>Less</code>, <code>Greater</code> e <code>Equal</code> (elas significam menor,
maior e igual, respectivamente). Estes são os três possíveis resultados quando
você compara dois valores.</p>
<p>Depois, adicionamos cinco novas linhas no final que usam o tipo <code>Ordering</code>:</p>
<pre><code class="language-rust ignore">match palpite.cmp(&amp;numero_secreto) {
    Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
    Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
    Ordering::Equal =&gt; println!(&quot;Você acertou!&quot;),
}
</code></pre>
<p>O método <code>cmp</code> compara dois valores, e pode ser chamado a partir de qualquer
coisa que possa ser comparada. Ele recebe uma referência de qualquer coisa que
você queira comparar. Neste caso, está comparando o <code>palpite</code> com o
<code>numero_secreto</code>. <code>cmp</code> retorna uma variante do tipo <code>Ordering</code>, que trouxemos
ao escopo com <code>use</code>. Nós usamos uma expressão <a href="ch06-02-match.html"><code>match</code></a><!-- ignore -->
para decidir o que fazer em seguida, com base em qual variante de <code>Ordering</code> foi
retornada pelo método <code>cmp</code>, que foi chamado com os valores <code>palpite</code> e
<code>numero_secreto</code>.</p>
<p>Uma expressão <code>match</code> é composta de <em>braços</em>. Um braço consiste em um <em>padrão</em>
mais o código que deve ser executado se o valor colocado no início do <code>match</code> se
encaixar no padrão deste braço. O Rust pega o valor passado ao <code>match</code> e o
compara com o padrão de cada braço na sequência. A expressão <code>match</code> e os
padrões são ferramentas poderosas do Rust que lhe permitem expressar uma
variedade de situações que seu código pode encontrar, e ajuda a assegurar que
você tenha tratado todas elas. Essas ferramentas serão abordadas em detalhes nos
capítulos 6 e 18, respectivamente.</p>
<p>Vamos acompanhar um exemplo do que aconteceria na expressão <code>match</code> usada aqui.
Digamos que o usuário tenha colocado 50 como palpite, e o número secreto
aleatório desta vez é 38. Quando o código compara 50 com 38, o método <code>cmp</code> vai
retornar <code>Ordering::Greater</code>, porque 50 é maior que 38. <code>Ordering::Greater</code> é o
valor passado ao <code>match</code>. Ele olha para o padrão <code>Ordering::Less</code> do primeiro
braço, mas o valor <code>Ordering::Greater</code> não casa com <code>Ordering::Less</code>, então ele
ignora o código desse braço e avança para o próximo. Já o padrão do próximo
braço, <code>Ordering::Greater</code>, <em>casa</em> com <code>Ordering::Greater</code>! O código associado a
este braço vai ser executado e mostrar <code>Muito alto!</code> na tela. A expressão
<code>match</code> termina porque já não tem mais necessidade de verificar o último braço
nesse caso particular.</p>
<p>Porém, o código da Listagem 2-4 ainda não vai compilar. Vamos tentar:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
error[E0308]: mismatched types
  --&gt; src/main.rs:23:21
   |
23 |     match palpite.cmp(&amp;numero_secreto) {
   |                       ^^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   |
   = note: expected type `&amp;std::string::String`
   = note:    found type `&amp;{integer}`

error: aborting due to previous error
Could not compile `jogo_de_advinhacao`.
</code></pre>
<p>O que este erro está dizendo é que temos <em>tipos incompatíveis</em>. Rust tem um
sistema de tipos forte e estático. Porém, Rust também tem inferência de tipos.
Quando escrevemos <code>let palpite = String::new()</code>, Rust foi capaz de inferir que
<code>palpite</code> deveria ser uma <code>String</code>, então ele não nos faz escrever o tipo. O
<code>numero_secreto</code>, por outro lado, é de um tipo numérico. Existem alguns tipos
numéricos capazes de guardar um valor entre 1 e 100: <code>i32</code>, que é um número de
32 bits; <code>u32</code>, um número de 32 bits sem sinal; <code>i64</code>, um número de 64 bits; e
mais alguns outros. O tipo numérico padrão do Rust é <code>i32</code>, que é o tipo do
<code>numero_secreto</code>, a não ser que adicionemos, em algum lugar, uma informação de
tipo que faça o Rust inferir outro tipo numérico. A razão do erro é que o Rust
não pode comparar uma string e um tipo numérico.</p>
<p>Em última análise, queremos converter a <code>String</code> que lemos como entrada em um
tipo numérico de verdade, de forma que possamos compará-lo numericamente com o
palpite. Podemos fazer isso com mais duas linhas no corpo da função <code>main</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o número!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O número secreto é: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    let palpite: u32 = palpite.trim().parse()
        .expect(&quot;Por favor, digite um número!&quot;);

    println!(&quot;Você disse: {}&quot;, palpite);

    match palpite.cmp(&amp;numero_secreto) {
        Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
        Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
        Ordering::Equal =&gt; println!(&quot;Você acertou!&quot;),
    }
}
</code></pre>
<p>As duas linhas novas são:</p>
<pre><code class="language-rust ignore">let palpite: u32 = palpite.trim().parse()
    .expect(&quot;Por favor, digite um número!&quot;);
</code></pre>
<p>Nós criamos uma variável chamada <code>palpite</code>. Mas espera, o programa já não tinha
uma variável chamada <code>palpite</code>? Sim, mas o Rust nos permite <em>sombrear</em> o
<code>palpite</code> anterior com um novo. Isto é geralmente usado em situações em que você
quer converter um valor de um tipo em outro. O sombreamento nos permite
reutilizar o nome <code>palpite</code>, em vez de nos forçar a criar dois nomes únicos como
<code>palpite_str</code> e <code>palpite</code>, por exemplo. (O Capítulo 3 vai cobrir sombreamento em
mais detalhes).</p>
<p>Nós vinculamos <code>palpite</code> à expressão <code>palpite.trim().parse()</code>. O <code>palpite</code>, na
expressão, refere-se ao <code>palpite</code> original contendo a <code>String</code> de entrada do
usuário. O método <code>trim</code>, em uma instância de <code>String</code>, vai eliminar quaisquer
espaços em branco no início e no fim. <code>u32</code> pode conter apenas caracteres
numéricos, mas o usuário precisa pressionar <span class="keystroke">Enter</span>
para satisfazer o <code>read_line</code>. Quando o usuário pressiona
<span class="keystroke">Enter</span>, um caractere de nova linha é inserido na
string. Por exemplo, se o usuário digitar <span class="keystroke">5</span> e
depois <span class="keystroke">Enter</span>, <code>palpite</code> ficaria assim: <code>5\n</code>. O
<code>\n</code> representa uma linha nova, a tecla <span class="keystroke">Enter</span>.
O método <code>trim</code> elimina o <code>\n</code>, deixando apenas <code>5</code>.</p>
<p>O <a href="../../std/primitive.str.html#method.parse">método <code>parse</code> em strings</a><!-- ignore --> converte uma string para
algum tipo de número. Dado que ele pode interpretar uma variedade de tipos
numéricos, precisamos dizer ao Rust qual o tipo exato de número nós queremos, e
para isso usamos <code>let palpite: u32</code>. Os dois pontos (<code>:</code>) depois de <code>palpite</code>
informam ao Rust que estamos anotando seu tipo. O Rust tem alguns tipos
numéricos embutidos, o <code>u32</code> visto aqui é um inteiro de 32 bits sem sinal. É uma
boa escolha padrão para um número positivo pequeno. Você vai aprender sobre
outros tipos numéricos no Capítulo 3. Além disso, a anotação <code>u32</code> neste
programa de exemplo e a comparação com <code>numero_secreto</code> significam que o Rust
vai inferir que <code>numero_secreto</code> também deve ser um <code>u32</code>. Então agora a
comparação vai ser feita entre valores do mesmo tipo!</p>
<p>A chamada para <code>parse</code> poderia facilmente causar um erro. Por exemplo, se a
string contiver <code>A👍%</code>, não haveria como converter isto em um número. Como ele
pode falhar, o método <code>parse</code> retorna um <code>Result</code>, assim como o método
<code>read_line</code>, conforme discutido anteriormente na seção &quot;Tratando Potenciais
Falhas com o Tipo <code>Result</code>. Vamos tratar este <code>Result</code> da mesma forma usando o
método <code>expect</code> de novo. Se o <code>parse</code> retornar uma variante <code>Err</code> da enum
<code>Result</code>, por não conseguir criar um número a partir da string, a chamada ao
<code>expect</code> vai causar um <em>crash</em> no jogo e exibir a mensagem que passamos a ele.
Se o <code>parse</code> conseguir converter uma string em um número, ele vai retornar a
variante <code>Ok</code> da enum <code>Result</code> e <code>expect</code> vai retornar o número que queremos
extrair do valor <code>Ok</code>.</p>
<p>Agora vamos executar o programa!</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/jogo_de_advinhacao`
Advinhe o número!
O número secreto é: 58
Digite o seu palpite.
  76
Você disse: 76
Muito alto!
</code></pre>
<p>Boa! Até mesmo colocando alguns espaços antes de digitar o palpite, o programa
ainda descobriu que o palpite do usuário é 76. Execute o programa mais algumas
vezes para verificar os diferentes comportamentos com diferentes tipos de
entrada: advinhe o número corretamente, digite um número muito alto, e digite um
número muito baixo.</p>
<p>Agora já temos a maior parte do jogo funcionando, mas o usuário só consegue dar
um palpite uma vez. Vamos mudar isso adicionando laços!</p>
<a class="header" href="print.html#permitindo-múltiplos-palpites-usando-looping" id="permitindo-múltiplos-palpites-usando-looping"><h2>Permitindo Múltiplos Palpites Usando <em>Looping</em></h2></a>
<p>A palavra-chave <code>loop</code> nos dá um laço (<em>loop</em>) infinito. Use-a para dar aos
usuários mais chances de advinhar o número:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o número!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O número secreto é: {}&quot;, numero_secreto);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = palpite.trim().parse()
            .expect(&quot;Por favor, digite um número!&quot;);

        println!(&quot;Você disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; println!(&quot;Você acertou!&quot;),
        }
    }
}
</code></pre>
<p>Como você pode ver, movemos tudo para dentro do laço a partir da mensagem
pedindo o palpite do usuário. Certifique-se de indentar essas linhas mais quatro
espaços cada uma, e execute o programa novamente. Repare que há um novo
problema, porque o programa está fazendo exatamente o que dissemos para ele
fazer: pedir sempre outro palpite! Parece que o usuário não consegue sair!</p>
<p>O usuário pode sempre interromper o programa usando as teclas
<span class="keystroke">ctrl-c</span>. Mas há uma outra forma de escapar deste
monstro insaciável que mencionamos na discussão do método <code>parse</code>, na seção
&quot;Comparando o Palpite com o Número Secreto&quot;: se o usuário fornece uma resposta
não-numérica, o programa vai sofrer um <em>crash</em>. O usuário pode levar vantagem
disso para conseguir sair, como mostrado abaixo:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
     Running `target/jogo_de_advinhacao`
Advinhe o número!
O número secreto é: 59
Digite o seu palpite.
45
Você disse: 45
Muito baixo!
Digite o seu palpite.
60
Você disse: 60
Muito alto!
Digite o seu palpite.
59
Você disse: 59
Você acertou!
Digite o seu palpite.
sair
thread 'main' panicked at 'Por favor, digite um número!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/jogo_de_advinhacao` (exit code: 101)
</code></pre>
<p>Digitar <code>sair</code>, na verdade, sai do jogo, mas isso também acontece com qualquer
outra entrada não numérica. Porém, isto não é o ideal. Queremos que o jogo
termine automaticamente quando o número é advinhado corretamente.</p>
<a class="header" href="print.html#saindo-após-um-palpite-correto" id="saindo-após-um-palpite-correto"><h3>Saindo Após um Palpite Correto</h3></a>
<p>Vamos programar o jogo para sair quando o usuário vencer, colocando um <code>break</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o número!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O número secreto é: {}&quot;, numero_secreto);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = palpite.trim().parse()
            .expect(&quot;Por favor, digite um número!&quot;);

        println!(&quot;Você disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Você acertou!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Adicionando a linha <code>break</code> após o <code>Você acertou!</code>, o programa vai sair do laço
quando o usuário advinhar corretamente o número secreto. Sair do laço também
significa sair do programa, pois o laço é a última parte da <code>main</code>.</p>
<a class="header" href="print.html#tratando-entradas-inválidas" id="tratando-entradas-inválidas"><h3>Tratando Entradas Inválidas</h3></a>
<p>Para refinar ainda mais o comportamento do jogo, em vez de causar um <em>crash</em> no
programa quando o usuário insere uma entrada não numérica, vamos fazer o jogo
ignorá-la para que o usuário possa continuar tentando. Podemos fazer isso
alterando a linha em que o <code>palpite</code> é convertido de <code>String</code> para <code>u32</code>:</p>
<pre><code class="language-rust ignore">let palpite: u32 = match palpite.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
</code></pre>
<p>Trocando uma chamada a <code>expect</code> por uma expressão <code>match</code> é a forma como você
geralmente deixa de causar um <em>crash</em> em um erro e passa a tratá-lo, de fato.
Lembre-se que o método <code>parse</code> retorna um valor do tipo <code>Result</code>, uma enum que
contém a variante <code>Ok</code> ou <code>Err</code>. Estamos usando um <code>match</code> aqui, assim como
fizemos com o <code>Ordering</code> resultante do método <code>cmp</code>.</p>
<p>Se o <code>parse</code> consegue converter a string em um número, ele vai retornar um <code>Ok</code>
contendo o número resultante. Esse valor <code>Ok</code> vai casar com o padrão do primeiro
braço, e o <code>match</code> vai apenas retornar o valor <code>num</code> produzido pelo <code>parse</code> e
colocado dentro do <code>Ok</code>. Esse número vai acabar ficando exatamente onde
queremos, na variável <code>palpite</code> que estamos criando.</p>
<p>Se o <code>parse</code> <em>não</em> conseguir converter a string em um número, ele vai retornar
um <code>Err</code> que contém mais informações sobre o erro. O valor <code>Err</code> não casa com o
padrão <code>Ok(num)</code> do primeiro braço do <code>match</code>, mas casa com o padrão <code>Err(_)</code> do
segundo braço. O <code>_</code> é um valor &quot;pega tudo&quot;. Neste exemplo, estamos dizendo que
queremos casar todos os valores <code>Err</code>, não importa qual informação há dentro
deles. Então o programa vai executar o código do segundo braço, <code>continue</code>, que
significa ir para a próxima iteração do <code>loop</code> e pedir outro palpite.
Efetivamente, o programa ignora todos os erros que o <code>parse</code> vier a encontrar!</p>
<p>Agora, tudo no programa deve funcionar como esperado. Vamos tentar executá-lo
usando o comando <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
     Running `target/jogo_de_advinhacao`
Advinhe o número!
O número secreto é: 61
Digite o seu palpite.
10
Você disse: 10
Muito baixo!
Digite o seu palpite.
99
Você disse: 99
Muito alto!
Digite o seu palpite.
foo
Digite o seu palpite.
61
Você disse: 61
Você acertou!
</code></pre>
<p>Demais! Com apenas um último ajuste, vamos finalizar o jogo de adivinhação:
lembre-se que o programa ainda está mostrando o número secreto. Isto foi bom
para testar, mas estraga o jogo. Vamos apagar o <code>println!</code> que revela o número
secreto. A Listagem 2-5 mostra o código final:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o número!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = match palpite.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;Você disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Você acertou!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">Listagem 2-5: Código completo do jogo de advinhação.
</span></p>
<a class="header" href="print.html#resumo" id="resumo"><h2>Resumo</h2></a>
<p>Neste ponto, você construiu com sucesso o jogo de adivinhação! Parabéns!</p>
<p>Este projeto foi uma forma prática de apresentar vários conceitos novos de Rust:
<code>let</code>, <code>match</code>, métodos, funções associadas, uso de crates externos, e outros.
Nos próximos capítulos, você vai aprender sobre esses conceitos em mais
detalhes. O Capítulo 3 aborda conceitos que a maioria das linguagens de
programação tem, como variáveis, tipos de dados e funções, e mostra como usá-los
em Rust. O Capítulo 4 explora posse (<em>ownership</em>), que é a característica do
Rust mais diferente das outras linguagens. O Capítulo 5 discute structs e a
sintaxe de métodos, e o Capítulo 6 se dedica a explicar enums.</p>
<a class="header" href="print.html#-conceitos-comuns-de-programação" id="-conceitos-comuns-de-programação"><h1>🇧🇷 Conceitos Comuns de Programação</h1></a>
<a class="header" href="print.html#-variáveis-e-mutabilidade" id="-variáveis-e-mutabilidade"><h1>🇧🇷 Variáveis e Mutabilidade</h1></a>
<a class="header" href="print.html#data-types" id="data-types"><h1>Data Types</h1></a>
<a class="header" href="print.html#how-functions-work" id="how-functions-work"><h1>How Functions Work</h1></a>
<a class="header" href="print.html#comments" id="comments"><h1>Comments</h1></a>
<a class="header" href="print.html#control-flow" id="control-flow"><h1>Control Flow</h1></a>
<a class="header" href="print.html#understanding-ownership" id="understanding-ownership"><h1>Understanding Ownership</h1></a>
<a class="header" href="print.html#what-is-ownership" id="what-is-ownership"><h1>What is Ownership?</h1></a>
<a class="header" href="print.html#references--borrowing" id="references--borrowing"><h1>References &amp; Borrowing</h1></a>
<a class="header" href="print.html#slices" id="slices"><h1>Slices</h1></a>
<a class="header" href="print.html#usando-structs-para-estruturar-dados-relacionados" id="usando-structs-para-estruturar-dados-relacionados"><h1>Usando Structs para Estruturar Dados Relacionados</h1></a>
<p>Uma <em>struct</em>, ou <em>estrutura</em>, é um tipo de dados personalizado que nos permite
nomear e criar um conjunto de vários valores relacionados que compõem um grupo
de dados. Se você estiver familiarizado com uma linguagem orientada a objeto,
um <em>struct</em> é como os atributos de dados de um objeto. Neste capítulo, vamos
comparar e diferenciar tuplas com structs, demonstrar como usar structs e
discutir como definir os métodos e funções associadas às structs para
especificar o comportamento associado com os dados de uma struct. Os conceitos
de struct e <em>enum</em> (que será discutido no Capítulo 6) são os blocos necessários
para a criação de novos tipos para o seu programa, para tirar o máximo proveito
da verificação de tipo no tempo de compilação do Rust.</p>
<a class="header" href="print.html#method-syntax" id="method-syntax"><h1>Method Syntax</h1></a>
<a class="header" href="print.html#enums-e-casamento-de-padrões-pattern-matching" id="enums-e-casamento-de-padrões-pattern-matching"><h1>Enums e Casamento de Padrões (<em>Pattern Matching</em>)</h1></a>
<p>Neste capítulo vamos ver <em>enumerações</em>, também chamadas de <em>enums</em>. Enums
permitem definir um tipo por meio da enumeração de seus possíveis valores.
Primeiro, vamos definir e usar uma enum para mostrar como ela pode atrelar
significado aos nossos dados. Depois, vamos explorar uma enum particularmente
útil, chamada <code>Option</code>, que expressa um valor que tanto pode ser algo quanto
pode não ser nada. Em seguida, vamos ver como o casamento de padrões por meio
da expressão <code>match</code> facilita a execução de códigos diferentes para diferentes
valores de uma enum. Por fim, vamos abordar o <code>if let</code>, outra forma concisa e
conveniente que você pode usar para tratar enums no seu código.</p>
<p>Enums são ferramentas que aparecem em muitas linguagens, mas suas
características variam de uma para outra. Em Rust, enums são mais parecidas com
os <em>tipos de dados algébricos</em> das linguagens de programação funcional como F#,
OCaml e Haskell.</p>
<a class="header" href="print.html#definindo-uma-enum" id="definindo-uma-enum"><h2>Definindo uma Enum</h2></a>
<p>Vamos ver um caso em que enums podem ser mais apropriadas do que structs e
descobrir como elas podem ser úteis. Digamos que estamos trabalhando com
endereços IP. Atualmente, existem duas versões do protocolo IP que são mais
utilizadas: a quatro e a seis. Estas são as únicas possibilidades para um
endereço IP com que o nosso programa vai trabalhar: nós podemos <em>enumerar</em>
todos os possíveis valores, é daí que vem o nome enumeração.</p>
<p>Um endereço IP qualquer pode ser ou da versão quatro ou da versão seis, mas
nunca das duas ao mesmo tempo. Esta propriedade dos endereços IP faz com que a
enum seja bem apropriada para este caso, pois enums só podem assumir o valor de
uma de suas variantes. Os endereços de ambas as versões, seja quatro ou seis,
ainda são, fundamentalmente, endereços IP, e deveriam ser tratados pelo mesmo
tipo no código em situações que se aplicam a qualquer versão de endereço IP.</p>
<p>Podemos expressar esse conceito em código definindo uma enum <code>VersaoIp</code> e
listando os possíveis tipos de que um endereço IP pode ser: <code>V4</code> e <code>V6</code>. Estas
são as chamadas <em>variantes</em> da enum:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum VersaoIp {
    V4,
    V6,
}
#}</code></pre></pre>
<p><code>VersaoIp</code> é um tipo de dados que agora nós podemos usar em qualquer lugar no
nosso código.</p>
<a class="header" href="print.html#valores-de-uma-enum" id="valores-de-uma-enum"><h3>Valores de uma Enum</h3></a>
<p>Podemos criar instâncias de cada uma das duas variantes de <code>VersaoIp</code>, da
seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
let quatro = VersaoIp::V4;
let seis = VersaoIp::V6;
#}</code></pre></pre>
<p>Repare que as variantes pertencem ao <em>namespace</em> da enum, e se usa <code>::</code> para
separar os dois. Isso é útil porque agora ambos os valores <code>VersaoIp::V4</code> e
<code>VersaoIp::V6</code> são do mesmo tipo: <code>VersaoIp</code>. Agora nós podemos, por exemplo,
definir uma função que usa qualquer <code>VersaoIp</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
fn rotear(versao_ip: VersaoIp) { }
#}</code></pre></pre>
<p>E podemos ainda chamar esta função passando qualquer uma das variantes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
# fn rotear(versao_ip: VersaoIp) { }
#
rotear(VersaoIp::V4);
rotear(VersaoIp::V6);
#}</code></pre></pre>
<p>O uso de enums tem ainda mais vantagens. Pensando mais a fundo sobre o nosso
tipo de endereço IP, ainda não temos uma forma de representar o <em>endereço</em> em
si, apenas sabemos qual a <em>versão</em> dele. Tendo em vista o que você acabou de
aprender sobre structs no Capítulo 5, você poderia abordar esse problema assim
como visto na Listagem 6-1:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum VersaoIp {
    V4,
    V6,
}

struct EnderecoIp {
    versao: VersaoIp,
    endereco: String,
}

let local = EnderecoIp {
    versao: VersaoIp::V4,
    endereco: String::from(&quot;127.0.0.1&quot;),
};

let loopback = EnderecoIp {
    versao: VersaoIp::V6,
    endereco: String::from(&quot;::1&quot;),
};
#}</code></pre></pre>
<p><span class="caption">Listagem 6-1: Representação do endereço e da variante
<code>VersaoIp</code> de um endereço IP usando uma <code>struct</code></span></p>
<p>Aqui nós definimos uma struct <code>EnderecoIp</code> que tem dois membros: <code>versao</code>, do
tipo <code>VersaoIp</code> (que definimos anteriormente) e <code>endereco</code>, do tipo <code>String</code>.
Temos duas instâncias dessa struct. A primeira, <code>local</code>, tem o valor
<code>VersaoIp::V4</code> como sua <code>versao</code>, e um endereço associado igual a <code>127.0.0.1</code>.
A segunda instância, <code>loopback</code>, tem como sua <code>versao</code> a outra variante de
<code>VersaoIp</code>, <code>V6</code>, e o endereço <code>::1</code> associado a ela. Nós usamos uma struct
para encapsular os valores de <code>versao</code> e <code>endereco</code>, agora a variante está
associada ao valor.</p>
<p>Podemos representar o mesmo conceito de uma forma mais concisa usando apenas
uma enum, em vez de uma enum dentro de uma struct, colocando dados dentro de
cada variante da enum, diretamente. Esta nova definição da enum <code>EnderecoIp</code>
diz que ambas as variantes, <code>V4</code> e <code>V6</code>, terão uma <code>String</code> associada:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum EnderecoIp {
    V4(String),
    V6(String),
}

let local = EnderecoIp::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = EnderecoIp::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>Podemos anexar dados a cada variante da enum diretamente, assim não existe mais
a necessidade de uma struct adicional.</p>
<p>Há uma outra vantagem de se usar uma enum em vez de uma struct: cada variante
pode conter dados de diferentes tipos e quantidades. Os endereços IP da versão
quatro têm sempre quatro componentes numéricas, cada uma com valor de 0 a 255.
Se quiséssemos representar endereços <code>V4</code> como quatro valores <code>u8</code>, e ao mesmo
tempo manter os endereços <code>V6</code> como uma <code>String</code>, não poderíamos usar uma
struct. Já as enums podem facilmente atender a este caso:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum EnderecoIp {
    V4(u8, u8, u8, u8),
    V6(String),
}

let local = EnderecoIp::V4(127, 0, 0, 1);

let loopback = EnderecoIp::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>Acabamos de ver algumas possibilidades que poderíamos usar para representar
endereços IP das duas versões por meio de uma enum. Acontece que essa
necessidade de representar endereços IP, incluindo sua versão, é tão comum que
a biblioteca padrão já possui uma definição que podemos usar! (<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">Veja a
documentação em inglês</a><!-- ignore -->). Vamos ver como a biblioteca
padrão define <code>IpAddr</code>: ele tem basicamente a mesma enum e as mesmas variantes
que nós definimos e usamos anteriormente, mas os dados do endereço são
embutidos dentro das variantes na forma de duas structs separadas, que são
definidas de um jeito diferente pra cada variante.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Ipv4Addr {
    // detalhes omitidos
}

struct Ipv6Addr {
    // detalhes omitidos
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#}</code></pre></pre>
<p>Esse código mostra que você pode colocar qualquer tipo de dados dentro de uma
variante de enum: strings, tipos numéricos ou structs, por exemplo. Você pode
até mesmo incluir outra enum! Além disso, os tipos definidos pela biblioteca
padrão não são tão mais complicados do que o que talvez você pensaria em fazer.</p>
<p>Repare que, mesmo havendo um <code>IpAddr</code>definido pela biblioteca padrão, nós ainda
podemos criar e utilizar nossa própria definição (com o mesmo nome, inclusive)
sem nenhum conflito, porque não trouxemos a definição da biblioteca padrão para
dentro do nosso escopo. Falaremos mais sobre a inclusão de tipos em um escopo
no Capítulo 7.</p>
<p>Vamos ver outro exemplo de uma enum na Listagem 6-2: esta tem uma grande
variedade de tipos embutidos nas suas variantes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Mensagem {
    Sair,
    Mover { x: i32, y: i32 },
    Escrever(String),
    MudarCor(i32, i32, i32),
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-2: Enum <code>Mensagem</code>, cujas variantes contêm,
cada uma, diferentes tipos e quantidades de dados</span></p>
<p>Esta enum tem quatro variantes de diferentes tipos:</p>
<ul>
<li><code>Sair</code> não tem nenhum dado associado.</li>
<li><code>Mover</code> contém uma struct anônima.</li>
<li><code>Escrever</code> contém uma única <code>String</code>.</li>
<li><code>MudarCor</code> contém três valores do tipo <code>i32</code>.</li>
</ul>
<p>Definir uma enum com variantes iguais às da Listagem 6-2 é similar a definir
diferentes tipos de struct, exceto que a enum não usa a palavra-chave <code>struct</code>,
e todas as variantes são agrupadas dentro do tipo <code>Mensagem</code>. As structs
seguintes podem guardar os mesmos dados que as variantes da enum anterior:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct MensagemSair; // unit struct
struct MensagemMover {
    x: i32,
    y: i32,
}
struct MensagemEscrever(String); // tuple struct
struct MensagemMudarCor(i32, i32, i32); // tuple struct
#}</code></pre></pre>
<p>Mas se usarmos structs diferentes, cada uma tendo seu próprio tipo, não vamos
conseguir tão facilmente definir uma função que possa receber qualquer um
desses tipos de mensagens, assim como fizemos com a enum <code>Mensagem</code>, definida
na Listagem 6-2, que consiste em um tipo único.</p>
<p>Há mais uma similaridade entre enums e structs: da mesma forma como podemos
definir métodos em structs usando <code>impl</code>, também podemos definir métodos em
enums. Aqui está um método chamado <code>invocar</code>, que poderia ser definido na nossa
enum <code>Mensagem</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Mensagem {
#     Sair,
#     Mover { x: i32, y: i32 },
#     Escrever(String),
#     MudarCor(i32, i32, i32),
# }
#
impl Mensagem {
    fn invocar(&amp;self) {
        // o corpo do método é definido aqui
    }
}

let m = Mensagem::Escrever(String::from(&quot;olá&quot;));
m.invocar();
#}</code></pre></pre>
<p>O corpo do método usaria o valor <code>self</code> para obter a mensagem sobre a qual o
método foi chamado. Neste exemplo, criamos a variável <code>m</code>, que contém o valor
<code>Mensagem::Escrever(String::from(&quot;olá&quot;))</code>, e é isso que <code>self</code> vai ser no corpo
do método <code>invocar</code> quando <code>m.invocar()</code> for executado.</p>
<p>Vamos ver agora outra enum da biblioteca padrão que também é muito útil e
comum: <code>Option</code>.</p>
<a class="header" href="print.html#a-enum-option-e-suas-vantagens-sobre-valores-nulos" id="a-enum-option-e-suas-vantagens-sobre-valores-nulos"><h3>A Enum <code>Option</code> e Suas Vantagens Sobre Valores Nulos</h3></a>
<p>Na seção anterior, vimos como a enum <code>EnderecoIp</code> nos permite usar o sistema de
tipos do Rust para codificar em nosso programa mais informação do que apenas os
dados que queremos representar. Essa seção explora um caso de estudo da
<code>Option</code>, que é outra enum definida pela biblioteca padrão. O tipo <code>Option</code> é
muito utilizado, pois engloba um cenário muito comum, em que um valor pode ser
algo ou pode não ser nada. Expressar esse conceito por meio do sistema de tipos
significa que o compilador pode verificar se você tratou, ou não, todos os
casos que deveriam ser tratados, podendo evitar <em>bugs</em> que são extremamente
comuns em outras linguagens de programação.</p>
<p>O <em>design</em> de uma linguagem de programação é geralmente tratado em termos de
quais características são incluídas, mas as que são excluídas também têm
importância. Rust não tem o valor nulo (<em>null</em>) que outras linguagens têm. O
valor nulo quer dizer que não há nenhum valor. Em linguagens que têm essa
característica, as variáveis sempre estão em um dos dois estados: nulo ou não
nulo.</p>
<p>Em uma conferência, Tony Hoare, inventor do valor nulo, disse o seguinte:</p>
<blockquote>
<p>Eu o chamo meu erro de um bilhão de dólares. Naquela época, eu estava
projetando o primeiro sistema abrangente de tipos para referências em uma
linguagem orientada a objetos. Meu objetivo era garantir que todo uso de
referências deveria ser absolutamente seguro, com verificação automática
feita pelo compilador. Mas não pude resistir à tentação de colocar uma
referência nula, simplesmente porque era tão fácil de implementar. Isso tem
provocado inúmeros erros, vulnerabilidades, e falhas de sistemas que
provavelmente causaram um bilhão de dólares de dor e danos nos últimos
quarenta anos.</p>
</blockquote>
<p>O problema com valores nulos é que, se você tentar usar um valor nulo como se
fosse não nulo, vai acontecer algum tipo de erro. Pelo fato dessa propriedade
de nulo e não nulo ser tão sutil, é extremamente fácil cometer esse tipo de
erro.</p>
<p>Porém, o conceito que o valor nulo tenta expressar ainda é útil: um valor nulo
representa algo que, por algum motivo, está inválido ou ausente no momento.</p>
<p>O problema, na verdade, não está no conceito, mas na implementação em
particular. Por isso, Rust não possui valores nulos, mas sim uma enum que
engloba o conceito de um valor estar presente ou ausente. Esta enum é a
<code>Option&lt;T&gt;</code>, que está definida na biblioteca padrão da seguinte forma:
(<a href="https://doc.rust-lang.org/std/option/enum.Option.html">Veja a documentação em inglês</a><!-- ignore -->).</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T), // algum valor
    None, // nenhum valor
}
#}</code></pre></pre>
<p>A enum <code>Option&lt;T&gt;</code> é tão útil que ela já vem inclusa no prelúdio: você não
precisa trazê-la explicitamente para o seu escopo. Além disso, o mesmo ocorre
com suas variantes: você pode usar <code>Some</code> e <code>None</code> diretamente sem prefixá-las
com <code>Option::</code>. <code>Option&lt;T&gt;</code> continua sendo uma enum como qualquer outra, e
<code>Some(T)</code> e <code>None</code> ainda são variantes do tipo <code>Option&lt;T&gt;</code>.</p>
<p>A sintaxe do <code>&lt;T&gt;</code> é uma característica do Rust de que não falamos ainda.
Trata-se de um parâmetro de tipo genérico, vamos abordá-lo com mais detalhe no
Capítulo 10. Por ora, tudo que você precisa saber é que <code>&lt;T&gt;</code> significa que a
variante <code>Some</code> da enum <code>Option</code> pode conter um dado de qualquer tipo. Aqui vão
alguns exemplos de <code>Option</code> contendo tipos de número e texto:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let algum_numero = Some(5);
let algum_texto = Some(&quot;um texto&quot;);

let numero_ausente: Option&lt;i32&gt; = None;
#}</code></pre></pre>
<p>Se usamos <code>None</code> em vez de <code>Some</code>, precisamos dizer ao Rust qual é o tipo de
<code>Option&lt;T&gt;</code> que nós temos, porque o compilador não consegue inferir qual tipo
estará contido na variante <code>Some</code> apenas olhando para um valor <code>None</code>.</p>
<p>Quando temos um <code>Some</code>, sabemos que um valor está presente, contido dentro do
<code>Some</code>. Já quando temos um <code>None</code>, de certa forma, significa o mesmo que um
valor nulo: não temos um valor que seja válido. Então por que a <code>Option&lt;T&gt;</code> é
tão melhor que usar um valor nulo?</p>
<p>Em resumo, é porque <code>Option&lt;T&gt;</code> e <code>T</code> (podendo <code>T</code> ser de qualquer tipo) são
tipos diferentes, por isso, o compilador não vai permitir usar um valor do tipo
<code>Option&lt;T&gt;</code> como se ele definitivamente tivesse um valor válido. Por exemplo,
o código seguinte não vai compilar, porque ele está tentando somar um <code>i8</code> a um
<code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore">let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let soma = x + y;
</code></pre>
<p>Quando executamos esse código, temos uma mensagem de erro como essa:</p>
<pre><code class="language-text">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is
not satisfied
 --&gt;
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
</code></pre>
<p>Intenso! O que essa mensagem quer dizer é que o Rust não consegue entender como
somar um <code>i8</code> e um <code>Option&lt;i8&gt;</code>, porque eles são de tipos diferentes. Quando
temos um valor de um tipo como <code>i8</code> em Rust, o compilador tem certeza de que
temos sempre um valor válido. Podemos prosseguir com confiança, sem ter de
verificar se o valor é nulo antes de usá-lo. Somente quando temos um
<code>Option&lt;i8&gt;</code> (ou qualquer que seja o tipo com que estamos trabalhando), vamos
ter de nos preocupar com a possibilidade de não haver um valor, e o compilador
vai se certificar de que nós estamos tratando este caso antes de usar o valor.</p>
<p>Em outras palavras, você tem que converter um <code>Option&lt;T&gt;</code> em um <code>T</code> antes de
poder executar operações com ele. Geralmente, isso ajuda a detectar um dos
problemas mais comuns com valores nulos: assumir que algo não é nulo quando,
na verdade, ele é.</p>
<p>Só de não ter que se preocupar com a possibilidade de ter deixado um valor nulo
escapar já lhe dá mais confiança em seu código. Pra ter um valor que pode ser
nulo em algum momento, você precisa, explicitamente, marcá-lo como sendo do
tipo <code>Option&lt;T&gt;</code>. A partir daí, sempre que for usar o valor, você será obrigado
a tratar, de forma explícita, o caso do valor sendo nulo. Sempre que houver um
valor que não seja um <code>Option&lt;T&gt;</code>, você <em>pode</em> assumir, com segurança, que o
valor não é nulo. Esta foi uma decisão deliberada de projeto do Rust para
limitar as sutilezas dos valores nulos e aumentar a segurança do código.</p>
<p>Então, como obter o valor <code>T</code> da variante <code>Some</code> quando se tem um <code>Option&lt;T&gt;</code>,
para que se possa usar seu valor? A enum <code>Option&lt;T&gt;</code> possui diversos métodos
que são úteis em uma variedade de situações, você pode pesquisá-los na
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">documentação</a><!-- ignore --> (em inglês). Será extremamente útil na sua
jornada com Rust se familizarizar com os métodos da enum <code>Option&lt;T&gt;</code>.</p>
<p>Em geral, pra usar um valor <code>Option&lt;T&gt;</code>, queremos ter um código que trate cada
uma das variantes. Queremos um código que só será executado quando tivermos um
valor <code>Some(T)</code>, e esse código terá permissão para usar o valor <code>T</code> que está
embutido. Queremos também um outro código que seja executado se tivermos um
valor <code>None</code>, e esse código não terá um valor <code>T</code> disponível. A expressão
<code>match</code> é uma instrução de controle de fluxo que faz exatamente isso quando
usada com enums: ela executa códigos diferentes dependendo de qual variante
tiver a enum, e esse código poderá usar os dados contidos na variante
encontrada.</p>
<a class="header" href="print.html#operador-match-de-controle-de-fluxo" id="operador-match-de-controle-de-fluxo"><h2>Operador <code>match</code> de Controle de Fluxo</h2></a>
<p>O Rust tem um excelente operador de controle de fluxo chamado <code>match</code>, que nos
permite comparar um valor com uma série de padrões e executar um código com
base no padrão que casar. Padrões podem ser compostos de valores literais,
variáveis, caracteres-curinga e várias outras coisas. O Capítulo 18 aborda
todos os tipos de padrões e o que eles fazem. A grande utilidade do <code>match</code> vem
da expressividade dos padrões e das análises feitas pelo compilador, tendo
certeza de que todos os casos possíveis estão sendo tratados.</p>
<p>Imagine que expressão <code>match</code> funciona como uma máquina de contar moedas: as
moedas passam por um canal que possui furos de vários tamanhos, e cada moeda
cai no primeiro furo em que ela couber. Da mesma forma, os valores passam por
cada padrão de um <code>match</code>, e logo no primeiro padrão que o valor &quot;se encaixar&quot;,
o bloco de código que estiver associado a ele será executado.</p>
<p>Aproveitando que acabamos de falar sobre moedas, vamos usá-las como exemplo de
utilização do <code>match</code>! Podemos escrever uma função que recebe uma moeda
qualquer dos Estados Unidos e, assim como uma máquina, determina qual moeda ela
é e retorna seu valor em <em>cents</em>, como mostra a Listagem 6-3:</p>
<blockquote>
<p><strong>Nota do tradutor:</strong> diferentemente do que acontece na maioria dos países,
as moedas dos Estados Unidos possuem nomes: as de 1 <em>cent</em> são chamadas de
<em>Penny</em>; as de 5 <em>cents</em>, de <em>Nickel</em>; as de 10 <em>cents</em>, de <em>Dime</em>; e as de 25
<em>cents</em>, de <em>Quarter</em>.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Moeda {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn valor_em_cents(moeda: Moeda) -&gt; u32 {
    match moeda {
        Moeda::Penny =&gt; 1,
        Moeda::Nickel =&gt; 5,
        Moeda::Dime =&gt; 10,
        Moeda::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-3: Uma enum e uma expressão <code>match</code> em que os
padrões comparados são as variantes da enum.</span></p>
<p>Vamos analisar o <code>match</code> da função <code>valor_em_cents</code>. Primeiro, usamos a
palavra-chave <code>match</code> seguida de uma expressão, que neste caso é o valor
<code>moeda</code>. É parecido a uma expressão utilizada com <code>if</code>, mas tem uma grande
diferença: com <code>if</code>, a expressão precisa retornar um valor <em>booleano</em>. Aqui,
pode ser de qualquer tipo. O tipo da variável <code>moeda</code>, neste exemplo, é a enum
<code>Moeda</code>, que definimos na Listagem 6-3.</p>
<p>Em seguida vêm os braços do <code>match</code>. Um braço é composto por duas partes: um
padrão e algum código. O primeiro braço deste exemplo tem um padrão, que é o
valor <code>Moeda::Penny</code>, e o operador <code>=&gt;</code> que separa o padrão do código associado
a ele. O código, nesse caso, é apenas o valor <code>1</code>. Os braços são separados uns
dos outros com uma vírgula.</p>
<p>Quando o <code>match</code> é executado, ele compara o valor resultante com o padrão de
cada braço, na ordem. Se o valor casar com um determinado padrão, o código
associado a esse padrão será executado. Se o valor não se encaixa nesse padrão,
a execução passa para o próximo braço, bem parecido com a máquina de contar
moedas. Podemos ter tantos braços quanto precisamos. No caso da Listagem 6-3,
nosso <code>match</code> tem quatro braços.</p>
<p>O código associado a cada braço é uma expressão, e o seu valor resultante, no
braço que combinar, é o que será retornado pela expressão <code>match</code>.</p>
<p>Tipicamente não se usa chaves se o braço do <code>match</code> for curto, como é o caso na
Listagem 6-3, em que cada braço retorna apenas um valor. Se você quiser
executar mais de uma linha de código em um braço, você pode usar chaves para
delimitá-las. Por exemplo, o código seguinte vai escrever na tela &quot;Moeda da
sorte!&quot; sempre que o método for chamado com uma <code>Moeda::Penny</code>, mas ainda vai
retornar o último valor do bloco, <code>1</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter,
# }
#
fn valor_em_cents(moeda: Moeda) -&gt; u32 {
    match moeda {
        Moeda::Penny =&gt; {
            println!(&quot;Moeda da sorte!&quot;);
            1
        },
        Moeda::Nickel =&gt; 5,
        Moeda::Dime =&gt; 10,
        Moeda::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#padrões-atrelados-a-valores" id="padrões-atrelados-a-valores"><h3>Padrões Atrelados a Valores</h3></a>
<p>Outra característica útil dos braços do <code>match</code> é que eles podem ser atrelados
a partes dos valores que se encaixam no padrão. É assim que podemos extrair
valores dentro de uma variante de uma enum.</p>
<p>Por exemplo, vamos alterar uma das nossas variantes, inserindo dados dentro
dela. De 1999 até 2008, os Estados Unidos cunhou <em>quarters</em> com um <em>design</em>
diferente para cada um dos 50 estados em um dos lados da moeda. Nenhuma outra
moeda tinha essa diferença no <em>design</em>, apenas os <em>quarters</em>. Podemos adicionar
essa informação à nossa <code>enum</code> alterando a variante <code>Quarter</code> para incluir o
valor <code>Estado</code>, como é feito na Listagem 6-4:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)] // Para podermos ver qual é o estado com mais facilidade
enum Estado {
    Alabama,
    Alaska,
    // ... etc
}

enum Moeda {
    Penny,
    Nickel,
    Dime,
    Quarter(Estado),
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-4: Enum <code>Moeda</code>, cuja variante <code>Quarter</code>
também guarda o valor <code>Estado</code>.</span></p>
<p>Vamos imaginar que um amigo nosso está tentando colecionar todas os <em>quarters</em>
dos 50 estados. Enquanto separamos nosso troco por tipo de moeda, vamos também
dizer o nome do estado associado a cada <em>quarter</em>. Se for um dos que o nosso
amigo ainda não tem, ele pode colocá-lo na sua coleção.</p>
<p>Na expressão <code>match</code> desse código, vamos adicionar uma variável chamada
<code>estado</code> ao padrão que casa com os valores da variante <code>Moeda::Quarter</code>. Quando
uma <code>Moeda::Quarter</code> é testada, a variável <code>estado</code> vai ser atrelada ao valor
do estado daquele <em>quarter</em>. Assim vamos poder usar o <code>estado</code> no código do
braço, desse jeito:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum Estado {
#    Alabama,
#    Alaska,
# }
#
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(Estado),
# }
#
fn valor_em_cents(moeda: Moeda) -&gt; u32 {
    match moeda {
        Moeda::Penny =&gt; 1,
        Moeda::Nickel =&gt; 5,
        Moeda::Dime =&gt; 10,
        Moeda::Quarter(estado) =&gt; {
            println!(&quot;Quarter do estado {:?}!&quot;, estado);
            25
        },
    }
}
#}</code></pre></pre>
<p>Se executarmos <code>valor_em_cents(Moeda::Quarter(Estado::Alaska))</code>, <code>moeda</code> seria
<code>Moeda::Quarter(Estado::Alaska)</code>. Quando comparamos esse valor em cada um dos
braços do <code>match</code>, nenhum deles vai casar enquanto não chegar em
<code>Moeda::Quarter(estado)</code>. Nesse ponto, <code>estado</code> vai estar atrelado ao valor
<code>Estado::Alaska</code>. Podemos, então, usar esse valor na expressão <code>println!</code>,
obtendo o estado contido na variante <code>Quarter</code> da enum <code>Moeda</code>.</p>
<a class="header" href="print.html#usando-match-com-optiont" id="usando-match-com-optiont"><h3>Usando <code>match</code> com <code>Option&lt;T&gt;</code></h3></a>
<p>Na seção anterior, queríamos obter o valor <code>T</code> contido em um <code>Some</code> quando era
o caso em uma <code>Option&lt;T&gt;</code>. Também podemos manipular uma <code>Option&lt;T&gt; usando</code>match<code>, assim como fizemos com a enum</code>Moeda<code>! Em vez de comparar moedas, vamos comparar as variantes de</code>Option<T><code>, mas a forma de trabalhar com a expressão</code>match` continua a mesma.</p>
<p>Digamos que queremos escrever uma função que recebe um <code>Option&lt;i32&gt;</code>, e se
houver um valor embutido nele, soma um a esse valor. Se não houver um valor,
a função deve retornar <code>None</code>, e nem tentar executar nenhuma operação.</p>
<p>Essa função é bem fácil de implementar, graças ao <code>match</code>, e vai ficar conforme
visto na Listagem 6-5:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn mais_um(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let cinco = Some(5);
let seis = mais_um(cinco);
let nenhum = mais_um(None);
#}</code></pre></pre>
<p><span class="caption">Listagem 6-5: Uma função que usa um <code>match</code> para tratar
uma <code>Option&lt;i32&gt;</code>.</span></p>
<a class="header" href="print.html#casando-somet" id="casando-somet"><h4>Casando <code>Some(T)</code></h4></a>
<p>Vamos examinar a primeira execução de <code>mais_um</code> em mais detalhes. Quando
chamamos <code>mais_um(cinco)</code>, a variável <code>x</code> no corpo da função <code>mais_um</code> vai ter
o valor <code>Some(5)</code>. Então comparamos ele a cada braço do <code>match</code>.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>O valor <code>Some(5)</code> não casa com o padrão <code>None</code>, então seguimos para o
próximo braço.</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<p><code>Some(5) casa com</code>Some(i)<code>? Sim, casa! Temos a mesma variante. O</code>i<code>está atrelado ao valor contido em</code>Some<code>, então</code>i<code>passa a ter o valor</code>5<code>. O código desse braço é executado, então somamos um ao valor de</code>i<code>e criamos um novo</code>Some<code>contendo nosso total de</code>6`.</p>
<a class="header" href="print.html#casando-none" id="casando-none"><h4>Casando <code>None</code></h4></a>
<p>Agora vamos considerar a segunda chamada da função <code>mais_um</code> na Listagem 6-5,
em que <code>x</code> é <code>None</code>. Nós entramos no <code>match</code> e comparamos com o primeiro braço.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>Confere! Não há nenhum valor para somar, então o programa pára e retorna o
valor <code>None</code> do lado direito do <code>=&gt;</code>. Como o primeiro braço já casou, nenhum
dos demais será testado.</p>
<p>A combinação de enums e a expressão <code>match</code> é útil em diversas situações. Você
verá muito esse padrão em Rust: fazer o <code>match</code> de uma enum, associar uma
variável ao valor embutido, e então executar um código baseado nele. Pode
parecer complicado no começo, mas uma vez que você se acostume, você vai querer
que tivesse isso em todas as linguagens. É, sistematicamente, um favorito dos
usuários.</p>
<a class="header" href="print.html#matches-são-exaustivos" id="matches-são-exaustivos"><h3><em>Matches</em> São Exaustivos</h3></a>
<p>Há outro aspecto do <code>match</code> que precisamos discutir. Considere essa versão da
nossa função <code>mais_um</code>:</p>
<pre><code class="language-rust ignore">fn mais_um(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre>
<p>Nós não tratamos o caso <code>None</code>, logo vai ocorrer um <em>bug</em> no nosso código. Por
sorte, é um <em>bug</em> que o Rust sabe detectar. Se tentarmos compilar esse código,
vamos ter esse erro:</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt;
  |
6 |         match x {
  |               ^ pattern `None` not covered
</code></pre>
<p>O Rust sabe que nós não cobrimos todos os casos possíveis, e sabe até de qual
padrão nos esquecemos! <em>Matches</em> em Rust são <em>exaustivos</em>: precisamos extinguir
até a última possibilidade pra que o nosso código seja válido. Especialmente no
caso de uma <code>Option&lt;T&gt;</code>, em que o Rust não nos deixa esquecer de tratar
explicitamente o caso <code>None</code>. Ele nos impede de assumir que temos um valor
válido quando possivelmente temos um valor nulo, e portanto, cometer o erro de
um bilhão de dólares que vimos mais cedo.</p>
<a class="header" href="print.html#the-_-placeholder" id="the-_-placeholder"><h3>The <code>_</code> Placeholder</h3></a>
<a class="header" href="print.html#o-placeholder-_" id="o-placeholder-_"><h3>O <em>Placeholder</em> <code>_</code></h3></a>
<p>O Rust também tem um padrão que podemos usar em situações em que não queremos
listar todos os valores possíveis. Por exemplo, um <code>u8</code> pode ter valores
válidos de 0 a 255. Se nos importamos apenas com os valores 1, 3, 5 e 7, não
queremos ser obrigados a listar o 0, 2, 4, 6, 8, 9, e assim por diante até 255.
Felizmente, nem precisamos: em vez disso, podemos usar o padrão especial <code>_</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let algum_valor_u8 = 0u8;
match algum_valor_u8 {
    1 =&gt; println!(&quot;um&quot;),
    3 =&gt; println!(&quot;três&quot;),
    5 =&gt; println!(&quot;cinco&quot;),
    7 =&gt; println!(&quot;sete&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p>O padrão <code>_</code> casa com qualquer valor. Colocando ele depois dos demais
braços, o <code>_</code> vai casar com todos os casos possíveis que não foram
especificados antes dele. O <code>()</code> é só o valor-unidade, pra que nada aconteça no
caso <code>_</code>. Como resultado, podemos dizer que não queremos fazer nada com os
possíveis valores que não listamos antes do <em>placeholder</em> <code>_</code>.</p>
<p>Contudo, a expressão <code>match</code> pode ser um tanto verbosa em uma situação em que
queremos apenas lidar com <em>um</em> dos casos. Pra essa situação, o Rust oferece o
<code>if let</code>.</p>
<a class="header" href="print.html#controle-de-fluxo-conciso-com-if-let" id="controle-de-fluxo-conciso-com-if-let"><h2>Controle de Fluxo Conciso com <code>if let</code></h2></a>
<p>A sintaxe do <code>if let</code> permite combinar <code>if</code> e <code>let</code> em uma forma menos verbosa
de tratar apenas os valores que casam com um padrão e ignorar os demais.
Considere o programa da Listagem 6-6, que confere um valor do tipo
<code>Option&lt;u8&gt;</code>, mas só executa um código se houver um valor associado igual a
três:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let algum_valor_u8 = Some(0u8);
match algum_valor_u8 {
    Some(3) =&gt; println!(&quot;três&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-6: Um <code>match</code> que só executa um código quando
o valor é <code>Some(3)</code>.</span></p>
<p>Queremos fazer alguma coisa com o <code>Some(3)</code>, mas não queremos fazer nada com
nenhum outro valor, seja <code>Some&lt;u8&gt;</code> ou <code>None</code>. Pra satisfazer a expressão
<code>match</code>, temos que colocar <code>_ =&gt; ()</code> após processar apenas uma variante, ou
seja, é muito código para pouca coisa.</p>
<p>Em vez disso, poderíamos escrever o mesmo código de uma forma mais compacta,
usando <code>if let</code>. O código seguinte tem o mesmo comportamento do <code>match</code> na
Listagem 6-6:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let algum_valor_u8 = Some(0u8);
if let Some(3) = algum_valor_u8 {
    println!(&quot;três&quot;);
}
#}</code></pre></pre>
<p><code>if let</code> recebe um padrão e uma expressão separados por um <code>=</code>. Isso funciona
da mesma forma que um <code>match</code>, em que a expressão seria passada para o <code>match</code>,
e o padrão apareceria no primeiro braço.</p>
<p>Usar o <code>if let</code> implica menos código pra digitar e menos indentação. Porém,
perdemos a verificação exaustiva que é garantida pelo <code>match</code>. A escolhe entre
<code>match</code> e <code>if let</code> depende do que você está fazendo em uma situação particular,
e se a redução no volume de código compensa a perda da verificação exaustiva.</p>
<p>Em outras palavras, você pode enxergar o <code>if let</code> como um <em>syntax sugar</em> (um
atalho) para um <code>match</code> que só executa um código quando o valor casa com um
único padrão, e ignora todos os outros valores.</p>
<p>Também podemos incluir um <code>else</code> em um <code>if let</code>. O bloco de código que vai no
<code>else</code> é o mesmo que iria no caso <code>_</code> da expressão <code>match</code> equivalente.
Lembre-se da enum <code>Moeda</code> que definimos na Listagem 6-4, cuja variante
<code>Quarter</code> guardava um valor do tipo <code>Estado</code>. Se queremos contar todas as
moedas que não forem <em>quarters</em>, enquanto também anunciamos o estado dos
<em>quarters</em>, poderíamos fazer isso com uma expressão <code>match</code> igual a esta:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum Estado {
#    Alabama,
#    Alaska,
# }
#
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(Estado),
# }
# let moeda = Coin::Penny;
let mut contagem = 0;
match moeda {
    Moeda::Quarter(estado) =&gt; println!(&quot;Quarter do estado {:?}!&quot;, estado),
    _ =&gt; contagem += 1,
}
#}</code></pre></pre>
<p>Ou poderíamos usar um <code>if let</code> e um <code>else</code> desta forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum Estado {
#    Alabama,
#    Alaska,
# }
#
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(Estado),
# }
# let moeda = Moeda::Penny;
let mut contagem = 0;
if let Moeda::Quarter(estado) = moeda {
    println!(&quot;Quarter do estado {:?}!&quot;, estado);
} else {
    contagem += 1;
}
#}</code></pre></pre>
<p>Se a lógica do seu programa fica muito verbosa quando é expressa por meio de um
<code>match</code>, lembre-se que você também dispõe do <code>if let</code>.</p>
<a class="header" href="print.html#resumo-1" id="resumo-1"><h2>Resumo</h2></a>
<p>Nós acabamos de ver como usar enums para criar tipos customizados a partir de
um conjunto de valores enumerados. Mostramos como o tipo <code>Option&lt;T&gt;</code>, da
biblioteca padrão, ajuda você a usar o sistema de tipos para evitar erros.
Quando as enums contêm dados, você pode usar <code>match</code> ou <code>if let</code> para extrair
e usar esses valores, dependendo de quantos casos você precisa tratar.</p>
<p>Agora, seus programas em Rust podem expressar conceitos em seu domínio usando
structs e enums. Criar tipos customizados para a sua <em>API</em> aumenta sua
segurança: o compilador vai se certificar de que suas funções recebem apenas
os valores que correspondem aos tipos esperados.</p>
<p>Para fornecer uma API bem organizada aos seus usuários, que seja simples de
usar, e que exponha apenas o que é necessário aos usuários, vamos agora passar
para os módulos em Rust.</p>
<a class="header" href="print.html#usando-módulos-para-reutilizar-e-organizar-código" id="usando-módulos-para-reutilizar-e-organizar-código"><h1>Usando Módulos para Reutilizar e Organizar Código</h1></a>
<p>Quando você começa a escrever programas em Rust, seu código pode se manter apenas na
função <code>main</code>. À medida que seu código cresce, você acabará por mover funcionalidades para
outras outras funções a fim de reutilizar código e melhorar a organização. Ao dividir seu código em
pequenos pedaços, cada pedaço é mais fácil de entender por si só. Mas o que acontece
se você tem muitas funções? Rust possui um sistema de módulos que permite a reutilização
de código de forma organizada.</p>
<p>Da mesma forma que você extrai linhas de código em uma função, você pode extrair
funções (e outros códigos, como structs e enums) em diferentes módulos. Um
<em>módulo</em> é um namespace que contém definições de funções ou tipos, e
você pode escolher se essas definições são visíveis fora de seu módulo
(público) ou não (privado). Aqui está uma visão geral de como os módulos funcionam:</p>
<ul>
<li>A palavra-chave <code>mod</code> declara um novo módulo. O código dentro do módulo aparece
   imediatamente após esta declaração dentro de chaves ou em
   outro arquivo.</li>
<li>Por padrão, as funções, tipos, constantes e módulos são privados. A palavra-chave <code>pub</code>
    torna um item público e, portanto, visível fora do seu namespace.</li>
<li>A palavra-chave <code>use</code> traz módulos, ou as definições dentro dos módulos, ao
   escopo, assim é mais fácil se referir a eles.</li>
</ul>
<p>Examinaremos cada uma dessas partes para ver como elas se encaixam no todo.</p>
<a class="header" href="print.html#mod-e-o-sistema-de-arquivos" id="mod-e-o-sistema-de-arquivos"><h2><code>mod</code> e o Sistema de Arquivos</h2></a>
<p>Vamos iniciar o nosso exemplo de módulo fazendo um novo projeto com o Cargo, mas em vez de
criar um crate binário, faremos um crate de biblioteca: um projeto que
as outras pessoas podem puxar para os seus projetos como uma dependência. Por exemplo, o crate <code>rand</code>
discutido no Capítulo 2, é um crate de biblioteca que usamos como uma dependência no
projeto do jogo de adivinhação.</p>
<p>Criaremos um esqueleto de uma biblioteca que fornece algumas funcionalidades gerais
de rede; nos concentraremos na organização dos módulos e funções,
mas não nos preocuparemos com o código que está dentro das funções. Chamaremos
nossa biblioteca de <code>communicator</code>. Por padrão, o Cargo criará uma biblioteca, a menos que
outro tipo de projeto seja especificado: se omitimos a opção <code>--bin</code>, que temos
usado em todos os capítulos anteriores a este, nosso projeto será um
biblioteca:</p>
<pre><code class="language-text">$ cargo new communicator
$ cd communicator
</code></pre>
<p>Observe que Cargo gerou <em>src/lib.rs</em> em vez de <em>src/main.rs</em>. Dentro de
<em>src/lib.rs</em> encontraremos o seguinte:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<p>Cargo cria um teste de exemplo para nos ajudar a começar nossa biblioteca, em vez de
o binário “Hello, world!” que recebemos quando usamos a opção <code>--bin</code>. Olharemos
a sintaxe <code>#[]</code> e <code>mod tests</code> no “Usando <code>super</code> para Acessar um
Módulo Pai” mais adiante neste capítulo, mas por agora, deixe este código
na parte inferior de <em>src/lib.rs</em>.</p>
<p>Como não temos um arquivo <em>src/main.rs</em>, não há nada para ser executado pelo Cargo
com o comando <code>cargo run</code>. Portanto, usaremos o comando  <code>cargo build</code>
para compilar o código da nossa biblioteca.</p>
<p>Examinaremos diferentes opções para organizar o código da sua biblioteca que serão
adequados em uma variedade de situações, dependendo da intenção do código.</p>
<a class="header" href="print.html#definições-do-módulo" id="definições-do-módulo"><h3>Definições do Módulo</h3></a>
<p>Para a nossa biblioteca de rede <code>communicator</code>, primeiro definiremos um módulo chamado
<code>network</code> que contém a definição de uma função chamada<code>connect</code>. Cada
definição de módulo em Rust começa com a palavra-chave <code>mod</code>. Adicione este código ao
início do arquivo <em>src/lib.rs</em>, acima do código de teste:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>Após a palavra-chave <code>mod</code>, colocamos o nome do módulo, <code>network</code> e, em seguida, um
bloco de código entre chaves. Tudo dentro deste bloco está dentro do
namespace <code>network</code>. Neste caso, temos uma única função, <code>connect</code>. Se nós
quisermos chamar essa função do código fora do módulo <code>network</code>, nós
precisaremos especificar o módulo e usar a sintaxe do namespace <code>::</code>, assim:
<code>network::connect()</code> em vez de apenas <code>connect()</code>.</p>
<p>Também podemos ter múltiplos módulos, lado a lado, no mesmo arquivo <em>src/lib.rs</em>.
Por exemplo, para ter mais um módulo <code>client</code> que possui uma função chamada <code>connect</code>
, podemos adicioná-lo como mostrado na Listagem 7-1:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}

mod client {
    fn connect() {
    }
}
#}</code></pre></pre>
<p><span class = "caption"> Listagem 7-1: O módulo <code>network</code> e o módulo <code>client</code>
definidos lado a lado em <em>src/lib.rs</em> </span></p>
<p>Agora, temos uma função <code>network::connect</code> e uma função <code>client::connect</code>.
Estas podem ter funcionalidades completamente diferentes, e os nomes das funções
não estão em conflito entre si porque estão em módulos diferentes.</p>
<p>Nesse caso, como estamos construindo uma biblioteca, o arquivo que serve como
ponto de entrada para construir nossa biblioteca é <em>src/lib.rs</em>. No entanto, em relação a
criação de módulos, não há nada de especial sobre <em>src/lib.rs</em>. Poderíamos também
criar módulos em <em>src/main.rs</em> para um crate binário da mesma forma que nós
criamos módulos em <em>src/lib.rs</em> para o crate de biblioteca. Na verdade, podemos colocar módulos
dentro de módulos, o que pode ser útil à medida que seus módulos crescem para manter juntas
funcionalidades relacionadas e separar funcionalidades não relacionadas. A
escolha de como você organiza seu código depende do que você pensa sobre a
relação entre as partes do seu código. Por exemplo, o código <code>client</code>
e a função <code>connect</code> podem ter mais sentido para os usuários de nossa biblioteca se
eles estivessem dentro do namespace <code>network</code>, como na Listagem 7-2:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }

    mod client {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class = "caption"> Listagem 7-2: Movendo o módulo <code>client</code> para dentro do
módulo <code>network</code></span></p>
<p>No seu arquivo <em>src/lib.rs</em>, substitua as definições <code>mod network</code> e <code>mod client</code>
pelas da Listagem 7-2, que possuem o módulo <code>client</code> como um
módulo interno da <code>network</code>. Agora temos as funções <code>network::connect</code> e
<code>network::client::connect</code>: novamente, as duas funções denominadas <code>connect</code> não conflitam
uma com a outra porque elas estão em diferentes namespaces.</p>
<p>Desta forma, os módulos formam uma hierarquia. O conteúdo de <em>src/lib.rs</em> está no
nível superior mais alto, e os submódulos estão em níveis mais baixos. Aqui está
a nossa organização quando pensada de forma hierárquica na Listagem 7-1:</p>
<pre><code class="language-text">communicator
 ├── network
 └── client
</code></pre>
<p>E aqui está a hierarquia correspondente ao exemplo na Listagem 7-2:</p>
<pre><code class="language-text">communicator
 └── network
     └── client
</code></pre>
<p>Conforme a hierarquia mostrada na Listagem 7-2, <code>client</code> é um filho do módulo <code>network</code>
em vez de um irmão. Projetos mais complicados podem ter muitos módulos, é necessário
organizá-los logicamente para mantê-los sob controle. O que &quot;logicamente&quot; significa em
seu projeto fica a seu critério, e depende do que você e os usuários da sua biblioteca
pensam sobre o domínio do seu projeto. Use as técnicas mostradas
aqui para criar módulos lado a lado e módulos aninhados em qualquer estrutura que
você queira.</p>
<a class="header" href="print.html#movendo-módulos-para-outros-arquivos" id="movendo-módulos-para-outros-arquivos"><h3>Movendo Módulos para Outros Arquivos</h3></a>
<p>Os módulos formam uma estrutura hierárquica, bem parecida com outra estrutura computacional
que você conhece: sistemas de arquivos! Podemos usar o sistema de módulos do Rust juntamente com
vários arquivos para dividir projetos Rust de forma que nem tudo resida em
<em>src/lib.rs</em> ou <em>src/main.rs</em>. Para este exemplo, vamos começar com o código em
Listagem 7-3:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod client {
    fn connect() {
    }
}

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 7-3: Três módulos, <code>client</code>, <code>network</code>, e
<code>network::server</code>, todos definidos em <em>src/lib.rs</em></span></p>
<p>O arquivo <em>src/lib.rs</em> possui esta hierarquia de módulos:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── server
</code></pre>
<p>Se esses módulos tivessem muitas funções, e elas estivessem se alongando muito,
seria difícil percorrer esse arquivo para encontrar o código com que queremos
trabalhar. Como as funções estão aninhadas dentro de um ou mais blocos <code>mod</code>,
as linhas de código dentro das funções começarão a se alongar também.
Estes seriam bons motivos para separar os módulos <code>client</code>, <code>network</code>, e <code>server</code>
de <em>src/lib.rs</em> e colocá-los em seus próprios arquivos.</p>
<p>Primeiro, substitua o código do módulo <code>client</code> por apenas a declaração do
módulo <code>client</code>, para que seu <em>src/lib.rs</em> se pareça com o código mostrado na Listagem 7-4:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
</code></pre>
<p><span class="caption"> Listagem 7-4: Extraindo o conteúdo do módulo <code>client</code>, mas deixando a declaração em <em>src/lib.rs</em> </span></p>
<p>Ainda estamos <em>declarando</em> o módulo <code>client</code> aqui, mas ao substituir o bloco
por um ponto e vírgula, estamos dizendo ao Rust para que procure, em outro local, o código
definido no escopo do módulo <code>client</code>. Em outras palavras, a linha <code>mod client;</code> significa:</p>
<pre><code class="language-rust ignore">mod client {
    // conteúdo de client.rs
}
</code></pre>
<p>Agora precisamos criar o arquivo externo com o nome do módulo. Crie um
arquivo <em>client.rs</em> em <em>src/</em> e abra-o. Em seguida digite o seguinte,
que é a função <code>connect</code> do módulo <code>client</code> que foi
removida na etapa anterior:</p>
<p><span class="filename">Arquivo: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>Observe que não precisamos de uma declaração <code>mod</code> neste arquivo porque já fizemos
a declaração do módulo <code>client</code> com <code>mod</code> em <em>src/lib.rs</em>. Este arquivo apenas
fornece o <em>conteúdo</em> do módulo <code>client</code>. Se colocarmos um <code>mod client</code> aqui,
nós estaríamos dando ao módulo <code>client</code> seu próprio submódulo chamado <code>client</code>!</p>
<p>Rust só sabe olhar em <em>src/lib.rs</em> por padrão. Se quisermos adicionar mais
arquivos para o nosso projeto, precisamos dizer ao Rust em <em>src/lib.rs</em> para procurar em outros
arquivos; é por isso que <code>mod client</code> precisa ser definido em <em>src/lib.rs</em> e não pode
ser definido em <em>src/client.rs</em>.</p>
<p>Agora, o projeto deve compilar com sucesso, embora você obtenha alguns
warnings (avisos). Lembre-se de usar <code>cargo build</code>, em vez de <code>cargo run</code>, porque temos
um crate de biblioteca em vez de um crate binário:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
warning: function is never used: `connect`
 --&gt; src/client.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/lib.rs:4:5
  |
4 | /     fn connect() {
5 | |     }
  | |_____^

warning: function is never used: `connect`
 --&gt; src/lib.rs:8:9
  |
8 | /         fn connect() {
9 | |         }
  | |_________^
</code></pre>
<p>Esses <em>warnings</em> nos dizem que temos funções que nunca são usadas. Não se preocupe
com esses <em>warnings</em> por enquanto; vamos abordá-los mais adiante neste capítulo, na
seção “Controlando a visibilidade com <code>pub</code>”. A boa notícia é que eles são apenas
<em>warnings</em>; nosso projeto foi construído com sucesso!</p>
<p>Em seguida, vamos extrair o módulo <code>network</code> em seu próprio arquivo usando o mesmo
procedimento. Em <em>src/lib.rs</em>, exclua o corpo do módulo <code>network</code> e adicione um
ponto e vírgula à declaração, assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network;
</code></pre>
<p>Em seguida, crie um novo arquivo <em>src/network.rs</em> e digite o seguinte:</p>
<p><span class="filename">Arquivo: src/network.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}

mod server {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>Observe que ainda temos uma declaração <code>mod</code> dentro deste arquivo de módulo; isto é
porque ainda queremos que <code>server</code> seja um submódulo de <code>network</code>.</p>
<p>Execute <code>cargo build</code> novamente. Sucesso! Temos mais um módulo para extrair: <code>server</code>.
Como ele é um submódulo - ou seja, um módulo dentro de outro - nossa tática atual de
extrair um módulo para um arquivo com o nome do módulo não funcionará. Iremos
tentar, de qualquer maneira, para que você possa ver o erro. Primeiro, altere o arquivo <em>src/network.rs</em> colocando
<code>mod server;</code> no lugar do conteúdo do módulo <code>server</code>:</p>
<p><span class="filename">Arquivo: src/network.rs</span></p>
<pre><code class="language-rust ignore">fn connect() {
}

mod server;
</code></pre>
<p>Em seguida, crie um arquivo <em>src/server.rs</em> e insira o conteúdo do módulo <code>server</code>
que extraímos:</p>
<p><span class="filename">Arquivo: src/server.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>Quando tentamos <code>cargo build</code>, obteremos o erro mostrado na Listagem 7-5:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
error: cannot declare a new module at this location
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
  |
note: maybe move this module `src/network.rs` to its own directory via `src/network/mod.rs`
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
note: ... or maybe `use` the module `server` instead of possibly redeclaring it
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
</code></pre>
<p><span class="caption">Listagem 7-5: Erro ao tentar extrair o submódulo <code>server</code>
em <em>src/server.rs</em> </span></p>
<p>O erro diz que não podemos declarar um novo módulo neste local (<code>cannot declare a new module at this location</code>)
e está apontando para a linha <code>mod server</code>; em <em>src/network.rs</em>. Então <em>src/network.rs</em> é
diferente de <em>src/lib.rs</em> de alguma forma: continue lendo para entender o porquê.</p>
<p>A nota no meio da Listagem 7-5 é realmente muito útil,
porque ela aponta para algo de que não falamos ainda:</p>
<pre><code class="language-text">note: maybe move this module `network` to its own directory via
`network/mod.rs`
</code></pre>
<p>(<strong>Tradução:</strong> talvez mover este módulo network para o seu próprio diretório via <code>network/mod.rs</code>)</p>
<p>Em vez de continuar a seguir o mesmo padrão de nomeação de arquivo usado
anteriormente, podemos fazer o que a nota sugere:</p>
<ol>
<li>Crie um novo <em>diretório</em> chamado <em>network</em>, o nome do módulo pai.</li>
<li>Mova o arquivo <em>src/network.rs</em> para o novo diretório <em>network</em> e
    renomeie para <em>src/network/mod.rs</em>.</li>
<li>Mova o arquivo de submódulo <em>src/server.rs</em> para o diretório <em>network</em>.</li>
</ol>
<p>Aqui estão os comandos para executar estas etapas:</p>
<pre><code class="language-text">$ mkdir src/network
$ mv src/network.rs src/network/mod.rs
$ mv src/server.rs src/network
</code></pre>
<p>Agora, quando tentamos executar <code>cargo build</code>, a compilação funcionará (embora ainda teremos
avisos). O layout dos nossos módulos ainda é exatamente o
mesmo de quando tínhamos todo o código em <em>src/lib.rs</em> na Listagem 7-3:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── server
</code></pre>
<p>O layout dos arquivos correspondentes agora ficou assim:</p>
<pre><code class="language-text">├── src
│   ├── client.rs
│   ├── lib.rs
│   └── network
│       ├── mod.rs
│       └── server.rs
</code></pre>
<p>Quando queríamos extrair o módulo <code>network::server</code>, por que precisávamos
também mudar o arquivo <em>src/network.rs</em> para o arquivo <em>src/network/mod.rs</em> e colocar
o código de <code>network::server</code> no diretório <em>network</em> em
<em>src/network/server.rs</em> em vez de apenas extrair o
módulo <code>network::server</code> em <em>src/server.rs</em>? O motivo é que Rust não
será capaz de reconhecer que <code>server</code> deveria ser um submódulo de <code>network</code>
se o arquivo <em>server.rs</em> estiver no diretório <em>src</em>. Para esclarecer o comportamento de Rust
aqui, consideremos um exemplo diferente com a seguinte hierarquia de módulos,
onde todas as definições estão em <em>src/lib.rs</em>:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── client
</code></pre>
<p>Neste exemplo, temos novamente três módulos : <code>client</code>,<code>network</code>, e
<code>network::client</code>. Seguindo os mesmos passos anteriores para extrair
módulos em arquivos, poderíamos criar <em>src/client.rs</em> para o módulo <code>client</code>.
Para o módulo <code>network</code>, poderíamos criar <em>src/network.rs</em>. Mas não seríamos
capazes de extrair o módulo <code>network::client</code> para um arquivo <em>src/client.rs</em>
porque ele já existe para o módulo <code>client</code> de nível superior! Se pudéssemos colocar
o código para <em>ambos</em> os módulos <code>client</code> e<code>network::client</code> no arquivo
<em>src/client.rs</em>, Rust não teria nenhuma maneira de saber se o código era
para <code>client</code> ou para <code>network::client</code>.</p>
<p>Portanto, para extrair um arquivo para o submódulo <code>network::client</code> do
módulo <code>network</code>, precisamos criar um diretório para o módulo <code>network</code>
em vez de um arquivo <em>src/network.rs</em>. O código que está no módulo <code>network</code>
entra no arquivo <em>src/network/mod.rs</em>, e o submódulo
<code>network::client</code> pode ter seu próprio arquivo <em>src/network/client.rs</em>. Agora o
o nível superior <em>src/client.rs</em> é inequivocamente o código que pertence ao
módulo <code>client</code>.</p>
<a class="header" href="print.html#regras-dos-módulos-e-seus-arquivos" id="regras-dos-módulos-e-seus-arquivos"><h3>Regras dos Módulos e Seus Arquivos</h3></a>
<p>Vamos resumir as regras dos módulos em relação aos arquivos:</p>
<ul>
<li>Se um módulo chamado <code>foo</code> não possui submódulos, você deve colocar as declarações
   para <code>foo</code> em um arquivo chamado <em>foo.rs</em>.</li>
<li>Se um módulo chamado <code>foo</code> possui submódulos, você deve colocar as declarações
   para <code>foo</code> em um arquivo chamado <em>foo/mod.rs</em>.</li>
</ul>
<p>Essas regras se aplicam de forma recursiva, então, se um módulo chamado <code>foo</code> tiver um submódulo chamado
<code>bar</code> e<code>bar</code> não possui submódulos, você deve ter os seguintes arquivos
no seu diretório <em>src</em>:</p>
<pre><code class="language-text">├── foo
│   ├── bar.rs (contém as declarações em `foo::bar`)
│   └── mod.rs (contém as declarações em `foo`, incluindo `mod bar`)
</code></pre>
<p>Os módulos devem ser declarados no arquivo do módulo pai usando a palavra-chave <code>mod</code>.</p>
<p>Em seguida, vamos falar sobre a palavra-chave <code>pub</code> e nos livrar dessas warnings!</p>
<a class="header" href="print.html#controlando-a-visibilidade-com-pub" id="controlando-a-visibilidade-com-pub"><h2>Controlando a Visibilidade com <code>pub</code></h2></a>
<p>Resolvemos as mensagens de erro mostradas na Listagem 7-5 movendo o código de <code>network</code> e
<code>network::server</code> para  os arquivos <em>src/network/mod.rs</em> e
<em>src/network/server.rs</em>, respectivamente. Nesse ponto, <code>cargo build</code> era
capaz de construir nosso projeto, mas ainda recebemos mensagens de <em>warning</em> sobre as
funções <code>client::connect</code>, <code>network::connect</code>, e <code>network::server::connect</code>
não estarem em uso:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/client.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>Então, por que estamos recebendo esses warnings(avisos)? Afinal, estamos construindo uma biblioteca
com funções que se destinam a ser usadas pelos nossos <em>usuários</em>, não necessariamente por
nós dentro de nosso próprio projeto, por isso não deveria importar que essas funções <code>connect</code>
não sejam utilizadas. O ponto de criá-las é que elas serão usadas por
outro projeto, não o nosso.</p>
<p>Para entender por que esse programa invoca esses warnings(avisos), vamos tentar usar a
biblioteca <code>connect</code> de outro projeto, chamando-a externamente. Para fazer isso,
vamos criar um crate binário no mesmo diretório que o nosso crate de biblioteca
inserindo um arquivo <em>src/main.rs</em> que contém esse código:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate communicator;

fn main() {
    communicator::client::connect();
}
</code></pre>
<p>Usamos o comando <code>extern crate</code> para trazer o crate de biblioteca <code>communicator</code>
para o escopo. Nosso pacote agora contém <em>duas</em> crates. Cargo trata <em>src/main.rs</em>
como um arquivo raiz de um crate binário, que é separado do crate de biblioteca existente
cujo arquivo raiz é <em>src/lib.rs</em>. Esse padrão é bastante comum para
projetos executáveis: a maioria das funcionalidades está em um crate de biblioteca e o crate binário
usa esse crate de biblioteca. Como resultado, outros programas também podem usar o
crate de biblioteca, e é uma boa separação de responsabilidades.</p>
<p>Do ponto de vista de um crate fora da biblioteca <code>communicator</code>
todos os módulos que criamos estão dentro de um módulo que tem o mesmo
nome como do crate, <code>communicator</code>. Chamamos o módulo de nível superior de um
crate de <em>módulo raiz</em>.</p>
<p>Observe também que, mesmo que estejamos usando um crate externo dentro de um submódulo do nosso
projeto, o <code>extern crate</code> deve entrar em nosso módulo raiz (então em <em>src/main.rs</em>
ou <em>src/lib.rs</em>). Então, em nossos submódulos, podemos consultar itens de crates externos
como se os itens fossem módulos de nível superior.</p>
<p>Agora, nosso crate binário apenas chama a função <code>connect</code> da nossa biblioteca do
módulo <code>client</code>. No entanto, invocar agora <code>cargo build</code> nos dará um erro
após os <em>warnings</em>:</p>
<pre><code class="language-text">error[E0603]: module `client` is private
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Ah ha! Este erro nos diz que o módulo <code>client</code> é privado, que é o
cerne das advertências. É também a primeira vez em que nos encontramos com os conceitos de
<em>público</em> e <em>privado</em> no contexto do Rust. O estado padrão de todos os códigos em
Rust é privado: ninguém mais tem permissão para usar o código. Se você não usar uma
função privada dentro do seu programa, como ele é o único código
permitido a usar essa função, Rust irá avisá-lo de que a função
não foi utilizada.</p>
<p>Depois de especificar que uma função como <code>client::connect</code> é pública, não só
será permitida a nossa chamada para essa função a partir de nosso crate binário, mas o
warning(aviso) de que a função não é utilizada irá desaparecer. Marcar uma função como pública
permite ao Rust saber que a função será usada por código fora do nosso programa.
Rust considera que agora é possível que a
função esteja &quot;sendo usada&quot;. Assim, quando uma função é marcada como pública, Rust não
exige que seja usada em nosso programa e deixará de avisar que a função
não é utilizada.</p>
<a class="header" href="print.html#fazendo-uma-função-pública" id="fazendo-uma-função-pública"><h3>Fazendo uma Função Pública</h3></a>
<p>Para dizer ao Rust que torne pública uma função, adicionamos a palavra-chave <code>pub</code> ao início
da declaração. Nos focaremos em corrigir o <em>warning</em> que indica
<code>client::connect</code> não foi utilizado por enquanto, assim como o erro <code>module `client` is private</code> (<code>módulo `client` é privado</code>) do nosso crate binário. Modifique <em>src/lib.rs</em> para tornar
o módulo <code>client</code> público, assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

mod network;
</code></pre>
<p>A palavra-chave <code>pub</code> é colocada logo antes do <code>mod</code>. Vamos tentar fazer o build novamente:</p>
<pre><code class="language-text">error[E0603]: function `connect` is private
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Opa! Temos um erro diferente! Sim, mensagens diferentes de erro
são motivo para comemorar. O novo erro mostra que que a função <code>connect</code> é privada
(function <code>connect</code> is private), então vamos editar <em>src/client.rs</em> para torná-la pública também:</p>
<p><span class="filename">Arquivo: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn connect() {
}
#}</code></pre></pre>
<p>Agora execute <code>cargo build</code> novamente:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>O código compila, e o warning(aviso) sobre <code>client::connect</code> não estar em uso
se foi!</p>
<p>Os avisos de código não utilizados nem sempre indicam que um item no seu código precisa
se tornar público: se você <em>não</em> quiser que essas funções façam parte de sua
API pública, <em>warnings</em> de código não utilizado podem alertá-lo de que esses códigos não são mais necessários,
e que podem ser excluídos com segurança. Eles também podem estar alertando você para um bug, caso você tivesse apenas
acidentalmente removido todos os lugares dentro da sua biblioteca onde esta função é
chamada.</p>
<p>Mas neste caso, nós <em>queremos</em> que as outras duas funções façam parte da nossa
API pública do crate, então vamos marcá-las como <code>pub</code> também para nos livrar dos
<em>warnings</em> remanescentes. Modifique <em>src/network/mod.rs</em> dessa forma:</p>
<p><span class="filename">Arquivo: src/network/mod.rs</span></p>
<pre><code class="language-rust ignore">pub fn connect() {
}

mod server;
</code></pre>
<p>Em seguida, compile o código:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / pub fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>Hmmm, ainda estamos recebendo um <em>warning</em> de função não utilizada, embora
<code>network::connect</code> esteja marcada como <code>pub</code>. A razão é que a função é pública
dentro do módulo, mas o módulo <code>network</code> na qual a função reside não é
público. Estamos trabalhando a partir do interior da biblioteca desta vez, enquanto que
com <code>client::connect</code> trabalhamos de fora. Precisamos mudar
<em>src/lib.rs</em> para tornar <code>network</code> pública também, assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;
</code></pre>
<p>Agora, quando compilamos, esse aviso desapareceu:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default
</code></pre>
<p>Apenas um warning(aviso) permanece. Tente consertar isso por conta própria!</p>
<a class="header" href="print.html#regras-de-privacidade" id="regras-de-privacidade"><h3>Regras de Privacidade</h3></a>
<p>No geral, estas são as regras para a visibilidade do item:</p>
<ol>
<li>Se um item for público, ele pode ser acessado através de qualquer um dos seus módulos pais.</li>
<li>Se um item é privado, ele só pode ser acessado por seu módulo pai imediato e
   qualquer um dos módulos filhos do pai.</li>
</ol>
<a class="header" href="print.html#exemplos-de-privacidade" id="exemplos-de-privacidade"><h3>Exemplos de Privacidade</h3></a>
<p>Vejamos mais alguns exemplos de privacidade para obter alguma prática. Crie um novo
projeto de biblioteca e digite o código da Listagem 7-6 no arquivo
<em>src/lib.rs</em> desse novo projeto:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod outermost {
    pub fn middle_function() {}

    fn middle_secret_function() {}

    mod inside {
        pub fn inner_function() {}

        fn secret_function() {}
    }
}

fn try_me() {
    outermost::middle_function();
    outermost::middle_secret_function();
    outermost::inside::inner_function();
    outermost::inside::secret_function();
}
</code></pre>
<p><span class="caption">Lista 7-6: Exemplos de funções públicas e privadas,
alguns dos quais estão incorretos</span></p>
<p>Antes de tentar compilar este código, tente um palpite sobre quais linhas na
função <code>try_me</code> terá erros. Em seguida, tente compilar o código para ver se
você estava certo e leia sobre a discussão dos erros!</p>
<a class="header" href="print.html#olhando-para-os-erros" id="olhando-para-os-erros"><h4>Olhando para os Erros</h4></a>
<p>A função <code>try_me</code> está no módulo raiz do nosso projeto. O módulo chamado
<code>outermost</code> é privado, mas a segunda regra de privacidade afirma que a função <code>try_me</code>
pode acessar o módulo <code>outermost</code> porque <code>outermost</code> está no
módulo atual (raiz), bem como <code>try_me</code>.</p>
<p>A chamada para <code>outermost::middle_function</code> funcionará porque <code>middle_function</code> é
pública e <code>try_me</code> está acessando <code>middle_function</code> através do seu módulo pai
<code>outermost</code>. Determinamos no parágrafo anterior que este módulo é
acessível.</p>
<p>A chamada para <code>outermost::middle_secret_function</code> causará um erro de compilação.
<code>middle_secret_function</code> é privado, então a segunda regra se aplica. O módulo raiz
não é nem o módulo atual de <code>middle_secret_function</code> (que seria o <code>outermost</code>),
nem um módulo filho do módulo atual de <code>middle_secret_function</code>.</p>
<p>O módulo denominado <code>inside</code> é privado e não tem módulos filhos, portanto, ele só pode
ser acessado pelo seu módulo atual <code>outermost</code>. Isso significa que a função <code>try_me</code>
não tem permissão de chamar <code>outermost::inside::inner_function</code> ou
<code>outermost::inside::secret_function</code>.</p>
<a class="header" href="print.html#reparando-os-erros" id="reparando-os-erros"><h4>Reparando os Erros</h4></a>
<p>Aqui estão algumas sugestões para alterar o código na tentativa de corrigir os
erros. Antes de tentar cada uma, tente adivinhar se ela irá consertar os
erros e, em seguida, compile o código para ver se você está certo ou não, usando as
regras de privacidade para entender o porquê.</p>
<ul>
<li>E se o módulo <code>inside</code> fosse público?</li>
<li>E se <code>outermost</code> fosse público e <code>inside</code> fosse privado?</li>
<li>E se, no corpo de <code>inner_function</code>, você chamasse o
  <code>::outermost::middle_secret_function()</code>? (Os dois dois pontos no início significam
   que queremos consultar os módulos a partir do módulo raiz.)</li>
</ul>
<p>Sinta-se livre para projetar mais experimentos que lhe vierem à mente!</p>
<p>Em seguida, vamos falar sobre trazer itens ao escopo com a palavra-chave <code>use</code>.</p>
<a class="header" href="print.html#referindo-se-a-nomes-em-módulos-diferentes" id="referindo-se-a-nomes-em-módulos-diferentes"><h2>Referindo-se a Nomes em Módulos Diferentes</h2></a>
<p>Vimos como chamar funções definidas dentro de um módulo usando o nome do módulo
como parte da chamada, como na chamada para a função <code>nested_modules</code> mostrada
aqui na Listagem 7-7:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

fn main() {
    a::series::of::nested_modules();
}
</code></pre></pre>
<p><span class="caption">Listagem 7-7: Chamando uma função especificando completamente
o caminho do módulo que a cerca</span></p>
<p>Como você pode ver, referir-se ao nome totalmente qualificado pode ficar bastante longo.
Felizmente, Rust tem uma palavra-chave para tornar estas chamadas mais concisas.</p>
<a class="header" href="print.html#trazendo-nomes-no-escopo-com-a-palavra-chave-use" id="trazendo-nomes-no-escopo-com-a-palavra-chave-use"><h3>Trazendo Nomes no Escopo com a Palavra-Chave <code>use</code></h3></a>
<p>A palavra-chave <code>use</code> de Rust encurta as chamadas de função longas, trazendo os módulos e
a função que deseja chamar para o escopo. Aqui está um exemplo de como trazer o
módulo <code>a::series::of</code> para dentro do escopo raiz de um crate binário:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

use a::series::of;

fn main() {
    of::nested_modules();
}
</code></pre></pre>
<p>A linha <code>use a::series::of;</code> significa que, em vez de usar todo o caminho
<code>a::series::of</code> sempre que quisermos nos referir ao módulo <code>of</code>, podemos usar
<code>of</code>.</p>
<p>A palavra-chave <code>use</code> traz apenas o que especificamos no escopo: ela não
leva os filhos dos módulos ao escopo. É por isso que ainda temos que usar
<code>of::nested_modules</code> quando queremos chamar a função <code>nested_modules</code>.</p>
<p>Poderíamos ter escolhido trazer a função para o escopo, em vez de especificar a função
no <code>use</code> da seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

use a::series::of::nested_modules;

fn main() {
    nested_modules();
}
</code></pre></pre>
<p>Isso nos permite excluir todos os módulos e fazer referência à função
diretamente.</p>
<p>Como as enums também formam uma espécie de <em>namespace</em>, assim como os módulos, podemos trazer
as variantes de uma enum para o escopo com <code>use</code> também. Para qualquer tipo de declaração de <code>use</code>
se você estiver trazendo vários itens de um <em>namespace</em> para o escopo, você pode listá-los
usando chaves e vírgulas na última posição, assim:</p>
<pre><pre class="playpen"><code class="language-rust">enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::{Red, Yellow};

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = TrafficLight::Green;
}
</code></pre></pre>
<p>Nós ainda estamos especificando o <em>namespace</em> <code>TrafficLight</code> para a variante <code>Green</code>
porque não incluímos <code>Green</code> na declaração <code>use</code>.</p>
<a class="header" href="print.html#trazendo-todos-os-nomes-para-o-escopo-com-um-glob" id="trazendo-todos-os-nomes-para-o-escopo-com-um-glob"><h3>Trazendo Todos os Nomes para o Escopo com um Glob</h3></a>
<p>Para trazer todos os itens de um <em>namespace</em> para o escopo ao mesmo tempo, podemos usar a sintaxe <code>*</code>, que é chamada de <em>operador glob</em>. Este exemplo traz todas as variantes de uma enum ao escopo sem ter que listar cada uma especificamente:</p>
<pre><pre class="playpen"><code class="language-rust">enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::*;

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = Green;
}
</code></pre></pre>
<p>O <code>*</code> trará para o escopo todos os itens visíveis no <em>namespace</em> <code>TrafficLight</code>.
Você deve usar globs com moderação: eles são convenientes, mas isso pode
também trazer mais itens do que se esperava e causar conflitos de nomeação.</p>
<a class="header" href="print.html#usando-super-para-acessar-um-módulo-pai" id="usando-super-para-acessar-um-módulo-pai"><h3>Usando <code>super</code> para Acessar um Módulo Pai</h3></a>
<p>Como vimos no início deste capítulo, quando você cria um crate de biblioteca,
o Cargo faz um módulo <code>tests</code> para você. Vamos ver isso em mais detalhes agora.
No seu projeto <code>communicator</code>, abra <em>src/lib.rs</em>:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre>
<p>O Capítulo 11 explica mais sobre testes, mas algumas partes deste exemplo devem fazer
sentido agora: temos um módulo chamado <code>tests</code> que se situa ao lado de nossos outros módulos
e contém uma função chamada <code>it_works</code>. Embora existam anotações especiais,
o módulo <code>tests</code> é apenas outro módulo! Então nossa hierarquia de módulos
se parece com isso:</p>
<pre><code class="language-text">communicator
 ├── client
 ├── network
 |   └── client
 └── tests
</code></pre>
<p>Os testes servem para exercitar o código dentro da nossa biblioteca, então vamos tentar chamar nossa
função <code>client :: connect</code> a partir da função<code>it_works</code>, mesmo que não verefiquemos nenhuma
funcionalidade agora. Isso ainda não funcionará:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<p>Execute os testes invocando o comando <code>cargo test</code>:</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
error[E0433]: failed to resolve. Use of undeclared type or module `client`
 --&gt; src/lib.rs:9:9
  |
9 |         client::connect();
  |         ^^^^^^ Use of undeclared type or module `client`
</code></pre>
<p>A compilação falhou, mas por quê? Não precisamos colocar <code>communicator ::</code> em
frente da função como fizemos em <em>src/main.rs</em> porque estamos definitivamente
dentro do crate da biblioteca <code>communicator</code> aqui. A razão é que os caminhos são
sempre relativos ao módulo atual, que aqui é <code>tests</code>. A única
exceção está em uma instrução <code>use</code>, onde os caminhos são relativos à crate raiz
por padrão. Nosso módulo <code>tests</code> precisa do módulo <code>client</code> no seu escopo!</p>
<p>Então, como podemos retroceder um módulo na hierarquia para chamar a
função <code>client::connect</code> no módulo <code>tests</code>? No módulo <code>tests</code>, temos a opção de
usar <code>::</code> na frente para indicar ao Rust que queremos começar a partir da raiz
e listar todo o caminho, assim:</p>
<pre><code class="language-rust ignore">::client::connect();
</code></pre>
<p>Ou, podemos usar <code>super</code> para voltar um módulo na hierarquia a partir de nosso
módulo atual, assim:</p>
<pre><code class="language-rust ignore">super::client::connect();
</code></pre>
<p>Essas duas opções não parecem tão diferentes neste exemplo, mas se você estiver
mais fundo em uma hierarquia de módulos, começar sempre a partir da raiz tornaria
seu código muito longo. Nesses casos, usar <code>super</code> para ir do módulo atual aos
módulos irmãos é um bom atalho. Além disso, se você especificou o caminho a partir da
raiz em muitos lugares do seu código e depois vai reorganizar seus módulos movendo
uma sub-árvore para outro lugar, você acabaria precisando atualizar o caminho em vários
lugares, o que seria tedioso.</p>
<p>Também seria chato ter que digitar <code>super ::</code> em cada teste, mas você
já viu a ferramenta para essa solução: <code>use</code>! A funcionalidade <code>super ::</code>
altera o caminho que você dá para <code>use</code>, tornando-o relativo ao módulo pai
em vez do módulo raiz.</p>
<p>Por estas razões, especialmente no módulo <code>tests</code>, <code>use super::alguma_coisa</code> é
geralmente a melhor solução. Então, agora nosso teste ficou assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::client;

    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<p>Quando executarmos novamente <code>cargo test</code>, o teste passará e a primeira parte do
resultado do teste será o seguinte:</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
     Running target/debug/communicator-92007ddb5330fa5a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<a class="header" href="print.html#resumo-2" id="resumo-2"><h2>Resumo</h2></a>
<p>Agora você conhece algumas técnicas novas para organizar o seu código! Use estas técnicas
para agrupar as funcionalidades relacionadas, evitar que os arquivos tornem-se muito longos, e
apresentar uma API pública arrumada para os usuários da sua biblioteca.</p>
<p>Em seguida, analisaremos algumas estruturas de dados de coleções na biblioteca padrão
que você pode usar em seu código limpo e elegante!</p>
<a class="header" href="print.html#fundamental-collections" id="fundamental-collections"><h1>Fundamental Collections</h1></a>
<a class="header" href="print.html#vetores" id="vetores"><h2>Vetores</h2></a>
<p>O primeiro tipo que iremos ver é <code>Vec&lt;T&gt;</code>, também conhecido como <em>vetor</em>. Vetores
permitem guardar mais de um valor na mesma estrutura de dados que coloca todos
os valores um ao lado do outro na memória. Vetores só podem guardar valores do
mesmo tipo. Eles são úteis em situações onde há uma lista de itens, como
as linha de texto em um arquivo ou preços de itens em um carrinho de compras.</p>
<a class="header" href="print.html#criando-um-novo-vetor" id="criando-um-novo-vetor"><h3>Criando um Novo Vetor</h3></a>
<p>Para criar um novo vetor, vazio, chamamos a função <code>Vec::new</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;i32&gt; = Vec::new();
#}</code></pre></pre>
<p>Note que adicionamos uma anotação de tipo aqui. Como não estamos inserindo nenhum valor
no vetor, Rust não sabe o tipo de elementos que irá guardar.
Isto é um ponto importante. Vetores são homogêneos: eles podem guardar muitos
valores, mas todos esses valores devem ser do mesmo tipo. Vetores são implementados
usando genéricos, onde o capítulo 10 irá cobrir como usar em seus tipos. Por
agora, tudo o que precisa saber é que o tipo <code>Vec</code> fornecido pela biblioteca
padrão pode conter qualquer tipo, e quando um <code>Vec</code> específico possui um tipo específico, o
tipo vai dentro de <code>&lt; &gt;</code>. Falamos para Rust que <code>Vec</code> em <code>v</code> guardará
elementos do tipo <code>i32</code>.</p>
<p>No código real, a Rust pode inferir o tipo de valor que queremos armazenar uma vez que inserimos
valores, então você raramente precisa fazer essa anotação de tipo. É mais comum
criar um <code>Vec</code> que possui valores iniciais, e o Rust fornece a macro <code>vec!</code> por
conveniência. A macro criará um novo <code>Vec</code> que contém os valores que damos
. Isso criará um novo <code>Vec &lt;i32&gt;</code> que contém os valores <code>1</code>,<code>2</code> e <code>3</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];
#}</code></pre></pre>
<p>Como nós damos valores iniciais  <code>i32</code>, Rust pode inferir que o tipo de <code>v</code>
é <code>Vec &lt;i32&gt;</code>, e a anotação de tipo não é necessária. Vejamos a seguir como
modificar um vetor.</p>
<a class="header" href="print.html#modificando-um-vetor" id="modificando-um-vetor"><h3>Modificando um Vetor</h3></a>
<p>Para criar um vetor e adicionar elementos a ele, podemos usar o método <code>push</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
#}</code></pre></pre>
<p>Como qualquer variável que discutimos no Capítulo 3, se quisermos poder
alterar seu valor, precisamos fazê-lo mutável com a palavra-chave <code>mut</code>. Os
números que inserimos são todos do tipo <code>i32</code>, e Rust infere isso dos
dados, por isso não precisamos da anotação <code>Vec &lt;i32&gt;</code>.</p>
<a class="header" href="print.html#descartar-um-vetor-descarta-seus-elementos" id="descartar-um-vetor-descarta-seus-elementos"><h3>Descartar um Vetor Descarta seus Elementos</h3></a>
<p>Como qualquer outro <code>struct</code>, um vetor será liberado quando ele sair do escopo:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let v = vec![1, 2, 3, 4];

    // use as informações em v

} // &lt;- v sai do escopo e é liberado aqui
#}</code></pre></pre>
<p>Quando o vetor é descartado, todos os seus conteúdos também será descartado, o que significa
esses inteiros que ele contém serão limpos. Isso pode parecer um
ponto direto, mas pode ficar um pouco mais complicado quando começamos a
introduzir referências aos elementos do vetor. Vamos abordar isso em seguida!</p>
<a class="header" href="print.html#lendo-elementos-do-vetor" id="lendo-elementos-do-vetor"><h3>Lendo Elementos do Vetor</h3></a>
<p>Agora que você sabe como criar, atualizar e destruir vetores,
saber ler o seu conteúdo é um bom passo seguinte. Existem duas maneiras de fazer referência a
valores armazenados em um vetor. Nos exemplos, anotamos os tipos de
valores que são retornados dessas funções para maior clareza.</p>
<p>Este exemplo mostra os dois métodos de acesso a um valor em um vetor com
sintaxe de indexação ou o método <code>get</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
let third: Option&lt;&amp;i32&gt; = v.get(2);
#}</code></pre></pre>
<p>Há algumas coisas a serem observadas aqui. Primeiro, que usamos o valor do índice de <code>2</code>
para obter o terceiro elemento: os vetores são indexados por número, começando em zero.
Em segundo lugar, as duas maneiras diferentes de obter o terceiro elemento são: usando <code>&amp;</code> e
<code>[]</code>, que nos dá uma referência, ou usando o método <code>get</code> com o índice
passado como um argumento, o que nos dá uma <code>Option&lt;&amp;T&gt;</code>.</p>
<p>A razão pela qual Rust tem duas maneiras de fazer referência a um elemento é para que você possa escolher
como o programa se comporta quando você tenta usar um valor de índice para o qual
o vetor não tem um elemento correspondente. Por exemplo, o que um programa deve fazer se tiver
um vetor que contém cinco elementos, então tenta acessar um elemento no índice 100
dessa maneira:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
#}</code></pre></pre>
<p>Quando você executar isso, você verá que com o primeiro método <code>[]</code>, Rust irá
causar um <code>panic!</code> quando um elemento inexistente é referenciado. Este método seria
preferível se você quiser que seu programa considere uma tentativa de acessar um
elemento, passado o fim do vetor, para ser um erro fatal que deve finalizar o
programa.</p>
<p>Quando é passado um índice que está fora da matriz para o método <code>get</code>, ele
retorna <code>None</code> sem entrar em pânico. Você usaria isso se acessar um elemento
além do alcance do vetor ocorrerá ocasionalmente sob
circunstâncias normais. Seu código pode então ter lógica para lidar tanto com
<code>Some(&amp;element)</code> ou <code>None</code>, como discutimos no Capítulo 6. Por exemplo, o
O índice pode ser proveniente de uma pessoa que digite um número. Se eles acidentalmente
insira um número que é muito grande e seu programa recebe um valor <code>None</code>, você poderia
dizer ao usuário quantos itens estão no atual <code>Vec</code> e dar uma nova
chance de inserir um valor válido. Isso seria mais amigável do que quebrar o
programa por um erro de digitação!</p>
<a class="header" href="print.html#referências-inválidas" id="referências-inválidas"><h4>Referências Inválidas</h4></a>
<p>Uma vez que o programa tenha uma referência válida, o verificador de empréstimo (borrow checker) faz valer
as regras de propriedade e empréstimo abrangidas no Capítulo 4 para garantir que essa referência e
quaisquer outras referências aos conteúdos do vetor permaneçam válidas. Lembre-se da regra
que diz que não podemos ter referências mutáveis e imutáveis no mesmo escopo.
Essa regra se aplica neste exemplo, onde mantemos uma referência imutável ao
primeiro elemento em um vetor e tentamos adicionar um elemento ao final:</p>
<pre><code class="language-rust ignore">let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);
</code></pre>
<p>Compilar isso nos dará esse erro:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `v` as mutable because it is also borrowed as
immutable
  |
4 | let first = &amp;v[0];
  |              - immutable borrow occurs here
5 |
6 | v.push(6);
  | ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>Este código pode parecer que deveria funcionar: por que uma referência ao primeiro
elemento deveria se preocupar com o que muda sobre o final do vetor? A razão porque
este código não é permitido é devido à forma como os vetores funcionam. Adicionando um novo elemento
no final do vetor pode exigir a atribuição de nova alocação de memória e copiar os
elementos antigos para o novo espaço, na circunstância de não haver espaço suficiente
para colocar todos os elementos próximos um do outro onde o vetor estava. Nesse
caso, a referência ao primeiro elemento apontaria para memória não alocada.
As regras de empréstimo impedem que os programas acabem nessa situação.</p>
<blockquote>
<p>Nota: para mais informações, veja o Rustonomicon em
<em>https://doc.rust-lang.org/stable/nomicon/vec.html</em>.</p>
</blockquote>
<a class="header" href="print.html#usando-um-enum-para-armazenar-vários-tipos" id="usando-um-enum-para-armazenar-vários-tipos"><h3>Usando um Enum para Armazenar Vários Tipos</h3></a>
<p>No início deste capítulo, dissemos que os vetores só podem armazenar valores
que são todos do mesmo tipo. Isso pode ser inconveniente; definitivamente há casos
de uso para a necessidade de armazenar uma lista de coisas de diferentes tipos. Felizmente,
as variantes de um enum são todas definidas sob o mesmo tipo de enum, então, quando precisamos
armazenar elementos de um tipo diferente em um vetor, podemos definir e usar um
enum!</p>
<p>Por exemplo, digamos que queremos obter valores de uma linha em uma planilha, onde
algumas das colunas da linha contêm números inteiros, alguns números de ponto flutuante,
e algumas strings. Podemos definir um enum cujas variantes guardarão os diferentes
tipos de valor, e então todas as variantes de enum serão consideradas do mesmos
tipo, o do enum. Então, podemos criar um vetor que contenha esse enum e
então, em última instância, possui diferentes tipos:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell::Float(10.12),
];
#}</code></pre></pre>
<p><span class="caption">Listagem 8-1: Definindo um enum para poder guardar
diferentes tipos de dados em um vetor</span></p>
<p>A razão pela qual Rust precisa saber exatamente quais tipos estarão no vetor em
tempo de compilação é para que ele saiba exatamente a quantidade de memória no heap que será
necessária para armazenar cada elemento. Uma vantagem secundária para isso é que podemos ser
explícitos sobre quais tipos são permitidos neste vetor. Se Rust permitisse um vetor
guardar qualquer tipo, haveria uma chance de que um ou mais dos tipos
causar erros com as operações realizadas nos elementos do vetor. Usando
um enum mais um <code>match</code> significa que a Rust garantirá no tempo de compilação que nós
sempre lidaremos com todos os casos possíveis, como discutimos no Capítulo 6.</p>
<p>Se você não sabe no momento em que você está escrevendo um programa, o conjunto exaustivo
dos tipos que o programa irá precisar no tempo de execução para armazenar em um vetor, a técnica de usar
o enum não funcionará. Em vez disso, você pode usar um objeto trait, que abordaremos no
Capítulo 17.</p>
<p>Agora que examinamos algumas das maneiras mais comuns de usar vetores, certifique-se
para dar uma olhada na documentação da API para todos os muitos métodos úteis
definidos no <code>Vec</code> pela biblioteca padrão. Por exemplo, além de <code>push</code>
existe um método <code>pop</code> que irá remover e retornar o último elemento. Vamos mover
para o próximo tipo de coleção: <code>String</code>!</p>
<a class="header" href="print.html#strings" id="strings"><h2>Strings</h2></a>
<p>Nós já conversamos sobre as strings no capítulo 4, mas vamos dar uma olhada mais
em profundidade agora. As strings são uma área que os novos Rustáceos geralmente tem maior
dificuldade. Isto é devido a uma combinação de três coisas: a propensão de Rust de
certificar-se de expor possíveis erros, as strings são estruturas de dados mais complicadas
que muitos programadores lhes dão crédito, e UTF-8. Essas coisas
combina de tal forma que parecem difícil quando se vem de outras linguagens.</p>
<p>A razão pela qual as strings estão no capítulo de coleções é que as strings são
implementadas como uma coleção de bytes mais alguns métodos para fornecer informações úteis e
funcionalidade quando esses bytes são interpretados como texto. Nesta seção, iremos
falar sobre as operações em <code>String</code> que todo tipo de coleção tem, como
criar, atualizar e ler. Também discutiremos as formas em que <code>String</code>
é diferente das outras coleções, a saber, como a indexação em um <code>String</code> é
complicada pelas diferenças entre como as pessoas e os computadores interpretam
dados <code>String</code>.</p>
<a class="header" href="print.html#o-que-é-string" id="o-que-é-string"><h3>O que é String?</h3></a>
<p>Antes de podermos explorar esses aspectos, precisamos falar sobre o que exatamente
significa o termo <em>string</em>. Rust realmente só tem um tipo de string no núcleo
da própria linguagem: <code>str</code>, a fatia de string, que geralmente é vista na forma emprestada
, <code>&amp;str</code>. Nós falamos sobre <em>fatias de strings</em> no Capítulo 4: estas são uma
referência a alguns dados de string codificados em UTF-8 armazenados em outro lugar. Literais de strings,
por exemplo, são armazenados na saída binária do programa e, portanto, são
fatias de string.</p>
<p>O tipo chamado <code>String</code> é fornecido na biblioteca padrão do Rust, em vez de
codificado no núleo da linguagem, e é um extensível, mutável, <code>owned</code>, tipo string
codificado UTF-8. Quando Rustáceos falam sobre “strings” em Rust, geralmente significa
tanto os tipos <code>String</code> quanto os tipos de string<code>&amp;str</code>, normalmente ambos.
Esta seção, é em grande parte sobre <code>String</code>, mas ambos esses tipos são usados em grande parte
na biblioteca padrão da Rust. Tanto o <code>String</code> como as fatias de string são codificadas em UTF-8.</p>
<p>A biblioteca padrão do Rust também inclui uma série de outros tipos de string, como
<code>OsString</code>,<code>OsStr</code>, <code>CString</code> e<code>CStr</code>. Bibliotecas crates podem fornecer
mais opções para armazenar dados de string. Semelhante ao nome <code>*String</code>/<code>*Str</code>,
elas geralmente fornecem uma variante owned e borrowed, assim como <code>String</code>/<code>&amp;str</code>.
Esses tipos de string podem armazenar diferentes codificações ou ser representados na memória de
maneira diferente, por exemplo. Nós não estaremos falando sobre esse outro tipo de string
neste capítulo; veja a documentação da API para obter mais informações sobre como usá-los
e quando cada um é apropriado.</p>
<a class="header" href="print.html#criando-uma-nova-string" id="criando-uma-nova-string"><h3>Criando uma Nova String</h3></a>
<p>Muitas das mesmas operações disponíveis com <code>Vec</code> também estão disponíveis em <code>String</code>,
começando com a função <code>new</code> para criar uma string, assim:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::new();
#}</code></pre></pre>
<p>Isso cria uma nova string vazia chamada <code>s</code> na qual podemos carregar dados.</p>
<p>Muitas vezes, teremos alguns dados iniciais que gostaríamos de já colocar na string.
Para isso, usamos o método <code>to_string</code>, que está disponível em qualquer tipo
que implementa a trait <code>Display</code>, como as strings literais:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let data = &quot;initial contents&quot;;

let s = data.to_string();

// o método também funciona em literais diretamente
let s = &quot;initial contents&quot;.to_string();
#}</code></pre></pre>
<p>Isso cria uma string contendo <code>initial contents</code>.</p>
<p>Também podemos usar a função <code>String :: from</code> para criar uma<code>String</code> de uma string
literal. Isso equivale a usar <code>to_string</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;initial contents&quot;);
#}</code></pre></pre>
<p>Como as strings são usadas para tantas coisas, existem várias APIs genéricas diferentes
que podem ser usadas para strings, então há muitas opções. Algumas delas
podem parecer redundantes, mas todas têm seu lugar! Nesse caso, <code>String :: from</code>
e <code>.to_string</code> acabam fazendo exatamente o mesmo, então a que você escolher é uma
questão de estilo.</p>
<p>Lembre-se de que as string são codificadas em UTF-8, para que possamos incluir qualquer dados apropriadamente codificados
neles:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;السلام عليكم&quot;;
let hello = &quot;Dobrý den&quot;;
let hello = &quot;Hello&quot;;
let hello = &quot;שָׁלוֹם&quot;;
let hello = &quot;नमस्ते&quot;;
let hello = &quot;こんにちは&quot;;
let hello = &quot;안녕하세요&quot;;
let hello = &quot;你好&quot;;
let hello = &quot;Olá&quot;;
let hello = &quot;Здравствуйте&quot;;
let hello = &quot;Hola&quot;;
#}</code></pre></pre>
<a class="header" href="print.html#atualizando-uma-string" id="atualizando-uma-string"><h3>Atualizando uma String</h3></a>
<p>Uma <code>String</code> pode crescer em tamanho e seu conteúdo pode mudar assim como o conteúdo
de um <code>Vec</code>, empurrando mais dados para ela. Além disso, <code>String</code> tem
operações de concatenação implementadas com o operador <code>+</code> por conveniência.</p>
<a class="header" href="print.html#anexando-a-uma-string-com-push" id="anexando-a-uma-string-com-push"><h4>Anexando a uma String com Push</h4></a>
<p>Podemos criar uma <code>String</code> usando o método <code>push_str</code> para adicionar uma  seqüência de caracteres:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
#}</code></pre></pre>
<p><code>s</code> conterá “foobar“ após essas duas linhas. O método <code>push_str</code> leva um
fatia de string porque não necessariamente queremos ownership do
parâmetro. Por exemplo, seria lamentável se não pudéssemos usar <code>s2</code>
depois de atualizar o seu conteúdo a <code>s1</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s1 = String::from(&quot;foo&quot;);
let s2 = String::from(&quot;bar&quot;);
s1.push_str(&amp;s2);
#}</code></pre></pre>
<p>O método <code>push</code> é definido para ter um único caractere como parâmetro e adicionar
à <code>String</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;lo&quot;);
s.push('l');
#}</code></pre></pre>
<p>Após isso, <code>s</code> irá conter “lol”.</p>
<a class="header" href="print.html#concatenação-com-o-operador--ou-a-macro-format" id="concatenação-com-o-operador--ou-a-macro-format"><h4>Concatenação com o Operador + ou a macro <code>format!</code></h4></a>
<p>Muitas vezes, queremos combinar duas strings existentes. Uma maneira é usar
o operador <code>+</code> dessa forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // Note que s1 foi movido aqui e não pode ser mais usado
#}</code></pre></pre>
<p>Após este código, a String <code>s3</code> conterá <code>Hello, world!</code>. O motivo que
<code>s1</code> não é mais válido após a adição e o motivo que usamos uma
referência a <code>s2</code> tem a ver com a assinatura do método que é chamado
quando usamos o operador <code>+</code>. O operador <code>+</code> usa o método <code>add</code>, cuja
assinatura parece algo assim:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>Esta não é a assinatura exata que está na biblioteca padrão; lá o <code>add</code> é
definido usando genéricos. Aqui, estamos olhando a assinatura do <code>add</code> com
tipos de concreto substituídos pelos genéricos, o que acontece quando nós
chamamos esse método com valores <code>String</code>. Vamos discutir genéricos no
Capítulo 10. Esta assinatura nos dá as pistas que precisamos para entender o complicado
operador <code>+</code>.</p>
<p>Antes de tudo, <code>s2</code> tem um <code>&amp;</code>, o que significa que estamos adicionando uma <em>referência</em> da
segunda string para a primeira string. Isso é devido ao parâmetro <code>s</code> na
função <code>add</code>: só podemos adicionar um <code>&amp;str</code> à <code>String</code>, não podemos adicionar dois
valores <code>String</code> juntos. Mas espere - o tipo de <code>&amp;s2</code> é <code>&amp;String</code>, não
<code>&amp;str</code>, conforme especificado no segundo parâmetro para<code>add</code>. Por que nosso exemplo
compila? Podemos usar <code>&amp;s2</code> na chamada para <code>add</code> porque um <code>&amp;String</code>
o argumento pode ser <em>coerced</em> em um <code>&amp;str</code> - quando a função<code>add</code> é chamada,
Rust usa algo chamado de <em>deref coercion</em>, o que você poderia pensar aqui como
virando <code>&amp;s2</code> para<code>&amp;s2[..]</code> para uso na função <code>add</code>. Vamos discutir deref
coercion  em maior profundidade no Capítulo 15. Como o <code>add</code> não se apropria
o parâmetro <code>s2</code> ainda será uma <code>String</code> válida após essa operação.</p>
<p>Em segundo lugar, podemos ver na assinatura que <code>add</code> toma posse de<code>self</code>,
porque <code>self</code> <em>não</em> tem <code>&amp;</code>. Isso significa <code>s1</code> no exemplo acima
será transferido para a chamada <code>add</code> e não será mais válido depois disso. Por enquanto
<code>let s3 = s1 + &amp;s2;</code> parece que irá copiar ambas as strings e criar uma nova,
esta declaração realmente adere a <code>s1</code>, acrescenta uma cópia do conteúdo
de <code>s2</code>, então retorna ownership do resultado. Em outras palavras, parece
estar fazendo muitas cópias, mas não é: a implementação é mais eficiente
do que copiar.</p>
<p>Se precisarmos concatenar várias strings, o comportamento de <code>+</code> fica complicado:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
#}</code></pre></pre>
<p><code>s</code> será “tic-tac-toe” neste momento. Com todos os <code>+</code> e <code>&quot;</code>,
fica difícil ver o que está acontecendo. Para strings mais complicadas
, podemos usar o macro <code>format!</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
#}</code></pre></pre>
<p>Este código também definirá <code>s</code> para “tic-tac-toe”. A macro <code>format!</code> funciona
do mesmo modo que <code>println!</code>, mas em vez de imprimir a saída para a tela, ela
retorna uma <code>String</code> com o conteúdo. Esta versão é muito mais fácil de ler, e
também não incide ownership em nenhum dos seus parâmetros.</p>
<a class="header" href="print.html#indexação-em-strings" id="indexação-em-strings"><h3>Indexação em Strings</h3></a>
<p>Em muitas outras linguagens, acessar caracteres individuais em uma string por
referenciando por índice é uma operação válida e comum. Em Rust, no entanto, se
nós tentamos acessar partes de uma <code>String</code> usando sintaxe de indexação, vamos ter um erro.
Ou seja, este código:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let h = s1[0];
</code></pre>
<p>resultará neste erro:</p>
<pre><code class="language-text">error: the trait bound `std::string::String: std::ops::Index&lt;_&gt;` is not
satisfied [--explain E0277]
  |&gt;
  |&gt;     let h = s1[0];
  |&gt;             ^^^^^
note: the type `std::string::String` cannot be indexed by `_`
</code></pre>
<p>O erro e a nota contam a história: as strings em Rust não suportam a indexação. Assim
a próxima pergunta é, por que não? Para responder a isso, temos que conversar um
pouco sobre como o Rust armazena strings na memória.</p>
<a class="header" href="print.html#representação-interna" id="representação-interna"><h4>Representação Interna</h4></a>
<p>Uma <code>String</code> é um invólucro sobre um <code>Vec &lt;u8&gt;</code>. Vejamos alguns dos nossos
exemplos UTF-8, codificadas corretamente, de strings vistas anteriormente. Primeiro, este:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Hola&quot;).len();
#}</code></pre></pre>
<p>Neste caso, <code>len</code> terá valor de quatro, o que significa que o<code>Vec</code> armazena a string
”Hola” tem quatro bytes de comprimento: cada uma dessas letras leva um byte quando codificado em
UTF-8. E o que acontece para esse exemplo?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Здравствуйте&quot;).len();
#}</code></pre></pre>
<p>Uma pessoa que pergunte pelo comprimento da string pode dizer que ela deva ter 12.No entanto, a resposta de Rust
é 24. Este é o número de bytes que é necessário para codificar “Здравствуйте“ em
UTF-8, uma vez que cada valor escalar Unicode leva dois bytes de armazenamento. Assim sendo,
um índice nos bytes da string nem sempre se correlaciona com um  valor escalar Unicode válido.</p>
<p>Para demonstrar, considere este código inválido do Rust:</p>
<pre><code class="language-rust ignore">let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];
</code></pre>
<p>Qual deve ser o valor da <code>answer</code>? Seria <code>З</code>, a primeira letra? Quando
codificado em UTF-8, o primeiro byte de <code>З</code> é <code>208</code>, e o segundo é <code>151</code>, então
a <code>answer</code> deve, na verdade, ser <code>208</code>, mas <code>208</code> não é um caractere válido em
si. Retornar <code>208</code> provavelmente não é o que uma pessoa gostaria se eles pedissem
a primeira letra desta string, mas esse é o único dado que Rust tem no byte
de índice 0. O retorno do valor do byte provavelmente não é o que as pessoas querem, mesmo com
caracteres contendo acentuação: <code>&amp;&quot;hello&quot;[0]</code> retornaria <code>104</code>, não<code>h</code>. Para evitar o
retornando um valor inesperado e causando erros que podem não ser descobertos
imediatamente, Rust escolhe não compilar este código e previne
mal-entendidos anteriormente.</p>
<a class="header" href="print.html#bytes-e-valores-escalares-e-clusters-de-grafemas-nossa" id="bytes-e-valores-escalares-e-clusters-de-grafemas-nossa"><h4>Bytes e Valores Escalares e Clusters de Grafemas! Nossa!</h4></a>
<p>Isso leva a outro ponto sobre UTF-8: existem realmente três maneiras relevantes
de olhar para as strings, da perspectiva do Rust: como bytes, valores escalares e
clusters de grafemas (a coisa mais próxima do que as pessoas chamariam <em>letras</em>).</p>
<p>Se olharmos para a palavra Hindi “नमस्ते” escrita na escrita Devanagari, é
em última instância, armazenada como um <code>Vec</code> de valores <code>u8</code> que se parece com isto:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Isso é 18 bytes, e é como os computadores de fato armazenam esses dados. Se olharmos para
eles como valores escalares Unicode, que são o tipo <code>char</code> de Rust, aqueles
bytes se parecem com isto:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>Existem seis valores <code>char</code> aqui, mas o quarto e o sexto não são letras,
Eles são diacríticos que não fazem sentido por conta própria. Finalmente, se olharmos para
eles como clusters de grafemas, teríamos o que uma pessoa chamaria as quatro letras
que compõem esta palavra:</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>Rust fornece diferentes maneiras de interpretar os dados de uma string bruta que os computadores
armazenem para que cada programa possa escolher a interpretação que necessite, não importa
em que idioma humano os dados estão.</p>
<p>Uma razão final do Rust não permitir que você indexe uma <code>String</code> para obter um
caracter é que as operações de indexação sempre esperam um tempo constante
(O(1)). Não é possível garantir que o desempenho com uma <code>String</code>,
entretanto, já que o Rust teria que percorrer todo o conteúdo desde o início
até o índice para determinar quantos caracteres válidos havia.</p>
<a class="header" href="print.html#fatiando-strings" id="fatiando-strings"><h3>Fatiando Strings</h3></a>
<p>Porque não está claro qual seria o tipo de retorno da indexação de string, e
muitas vezes é uma má idéia indexar uma string, Rust dissuade-o de fazê-lo
pedindo que você seja mais específico se você realmente precisar disso. Do jeito que você pode ser
mais específico que a indexação usando <code>[]</code> com um único número é usando <code>[]</code> com
um intervalo para criar uma fatia de string contendo bytes específicos:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
#}</code></pre></pre>
<p>Aqui, <code>s</code> será um <code>&amp;str</code> que contém os primeiros quatro bytes da string.
Mais cedo, mencionamos que cada um desses personagens era de dois bytes, de modo que
significa que <code>s</code> será “Зд”.</p>
<p>O que aconteceria se fizéssemos <code>&amp;hello[0..1]</code>? A resposta: entrará em pânico
em tempo de execução, da mesma maneira que acessar um índice inválido em um vetor:</p>
<pre><code class="language-text">thread 'main' panicked at 'index 0 and/or 1 in `Здравствуйте` do not lie on
character boundary', ../src/libcore/str/mod.rs:1694
</code></pre>
<p>Você deve usar isso com cautela, pois isso pode fazer com que seu programa falhe.</p>
<a class="header" href="print.html#métodos-para-interagir-sobre-strings" id="métodos-para-interagir-sobre-strings"><h3>Métodos para Interagir Sobre Strings</h3></a>
<p>Felizmente, existem outras maneiras de acessar elementos em um String.</p>
<p>Se precisarmos realizar operações em valores escalares Unicode individuais, a melhor
maneira de fazer isso é usar o método <code>chars</code>. Chamando <code>chars</code> em “नमस्ते”
é separado e retorna seis valores do tipo <code>char</code>, e você pode interar
no resultado para acessar cada elemento:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
#}</code></pre></pre>
<p>Este código irá imprimir:</p>
<pre><code class="language-text">न
म
स
्
त
े
</code></pre>
<p>O método <code>bytes</code> retorna cada byte bruto, que pode ser apropriado para o seu
domínio:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
#}</code></pre></pre>
<p>Este código imprimirá os 18 bytes que compõem esse <code>String</code>, começando por:</p>
<pre><code class="language-text">224
164
168
224
// ... etc
</code></pre>
<p>Mas lembre-se de que os valores escalares Unicode válidos podem ser constituídos por
mais de um byte.</p>
<p>Obter clusters de grafemas de strings é complexo, então esta funcionalidade não é
fornecida pela biblioteca padrão. Existem crates disponíveis em crates.io se
Esta é a funcionalidade que você precisa.</p>
<a class="header" href="print.html#as-strings-não-são-tão-simples" id="as-strings-não-são-tão-simples"><h3>As Strings Não são tão Simples</h3></a>
<p>Para resumir, as strings são complicadas. Diferentes linguagens de programação fazem
escolhas diferentes sobre como apresentar essa complexidade ao programador. Rust
optou por fazer o tratamento correto dos dados <code>String</code> o comportamento padrão
para todos os programas Rust, o que significa que os programadores devem pensar mais
no gerenciamento de dados UTF-8 antecipadamente. Este tradeoff expõe mais da complexidade
de strings do que outras linguagens de programação, mas isso irá impedi-lo de
ter que lidar com erros envolvendo caracteres não-ASCII mais tarde em seu
ciclo de desenvolvimento.</p>
<p>Vamos mudar para algo um pouco menos complexo: hash maps!</p>
<a class="header" href="print.html#hash-maps" id="hash-maps"><h2>Hash Maps</h2></a>
<p>A última das nossas coleções comuns é o <em>hash map</em>. O tipo <code>HashMap &lt;K, V&gt;</code>
armazena um mapeamento de chaves do tipo <code>K</code> para valores do tipo<code>V</code>. Ele faz isso através de um
<em>hashing function</em>, que determina como ele coloca essas chaves e valores em
memória. Muitas linguagens de programação diferentes suportam este tipo de
estrutura de dados, mas muitas vezes com um nome diferente: hash, map, object, hash table ou
associative array, apenas para citar alguns.</p>
<p>Os Hash maps são úteis para quando você deseja poder procurar dados sem uso de
índice, como você pode com vetores, mas usando uma chave que pode ser de qualquer tipo. Por
exemplo, em um jogo, você poderia acompanhar a pontuação de cada equipe em um hash map
onde cada chave é o nome de uma equipe e os valores são cada pontuação da equipe. Dado um
nome da equipe, você pode recuperar sua pontuação.</p>
<p>Examinaremos a API básica dos hash map neste capítulo, mas há muitos
mais coisas escondidas nas funções definidas no <code>HashMap</code> pela biblioteca
padrão. Como sempre, verifique a documentação da biblioteca padrão para mais
informação.</p>
<a class="header" href="print.html#criando-um-novo-hash-map" id="criando-um-novo-hash-map"><h3>Criando um novo Hash Map</h3></a>
<p>Podemos criar um <code>HashMap</code> vazio com <code>new</code>, e adicionar elementos com <code>insert</code>.
Aqui, estamos acompanhando as pontuações de duas equipes cujos nomes são Blue e
Yellow. A equipe blue começará com 10 pontos e a equipe yellow começa com
50:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
#}</code></pre></pre>
<p>Observe que precisamos primeiro <code>use</code> o <code>HashMap</code> da parte de coleções da
biblioteca padrão. De nossas três coleções comuns, esta é a de menor
frequencia de uso, por isso não está inclusa nos recursos importados automaticamente no
prelúdio. Os Hash maps também têm menos suporte da biblioteca padrão; não há
macro embutida para construí-los, por exemplo.</p>
<p>Assim como os vetores, os mapas hash armazenam seus dados no heap. Este <code>HashMap</code> tem
chaves do tipo <code>String</code> e valores do tipo <code>i32</code>. Como vetores, os hash maps são
homogêneos: todas as chaves devem ter o mesmo tipo e todos os valores
devem ter o mesmo tipo.</p>
<p>Outra maneira de construir um hash map é usando o método <code>collect</code> em um
vetor de tuplas, onde cada tupla consiste de uma chave e seu valor. O
método <code>collect</code> reúne dados em vários tipos de coleção, incluindo
<code>HashMap</code>. Por exemplo, se tivéssemos os nomes das equipes e as pontuações iniciais em dois
vetores separados, podemos usar o método <code>zip</code> para criar um vetor de tuplas
onde “Blue” é emparelhado com 10, e assim por diante. Então podemos usar o método <code>collect</code>
para transformar esse vetor de tuplas em um <code>HashMap</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let teams  = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];

let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
#}</code></pre></pre>
<p>A anotação de tipo <code>HashMap &lt;_, _&gt;</code> é necessária aqui porque é possível
<code>collect</code> em muitas estruturas de dados diferentes, e Rust não sabe qual você
deseja, a menos que você especifique. Para os parâmetros de tipo, para os tipos de chave e valor,
no entanto, usamos underscores e Rust pode inferir os tipos que o hash map
contém com base nos tipos de dados no vetor.</p>
<a class="header" href="print.html#hash-maps-e-ownership" id="hash-maps-e-ownership"><h3>Hash Maps e Ownership</h3></a>
<p>Para os tipos que implementam a <code>Copy</code> trait, como <code>i32</code>, os valores são copiados
no hash map. Para valores owned como <code>String</code>, os valores serão movidos e
o hash map será o owner desses valores:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let field_name = String::from(&quot;Favorite color&quot;);
let field_value = String::from(&quot;Blue&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name e field_value são inválidos neste ponto
#}</code></pre></pre>
<p>Não poderíamos usar as ligações <code>field_name</code> e<code>field_value</code> depois
que foram transferidos para o hash map com a chamada para <code>insert</code>.</p>
<p>Se inserimos referências a valores no hash map, os próprios valores
não serão movido para o hash map. Os valores que as referências apontam devem ser
válido pelo menos enquanto o hash map seja válido, no entanto. Falaremos mais
sobre esses problemas na seção Lifetimes do Capítulo 10.</p>
<a class="header" href="print.html#acessando-valores-em-um-hash-map" id="acessando-valores-em-um-hash-map"><h3>Acessando Valores em um Hash Map</h3></a>
<p>Podemos obter um valor do hash map fornecendo a chave para o método <code>get</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);
#}</code></pre></pre>
<p>Aqui, <code>score</code> terá o valor que está associado à equipe Blue, e o
resultado será <code>Some(&amp;10)</code>. O resultado está envolvido em <code>Some</code> porque <code>get</code>
retorna <code>Option&lt;&amp;V&gt;</code>; se não houver valor para essa chave no hash map, <code>get</code>
retornará <code>None</code>. O programa precisará lidar com <code>Option</code> em uma das
formas que abordamos no Capítulo 6.</p>
<p>Podemos iterar sobre cada par chave/valor em um hash map de uma maneira similar à que
fazemos com vetores, usando um loop <code>for</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
#}</code></pre></pre>
<p>Isso imprimirá cada par, em uma ordem arbitrária:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<a class="header" href="print.html#atualizando-um-hash-map" id="atualizando-um-hash-map"><h3>Atualizando um Hash Map</h3></a>
<p>Embora o número de chaves e valores sejam crescentes, cada chave individual pode apenas
tem um valor associado a ele por vez. Quando queremos mudar os dados em
um hash map, temos que decidir como lidar com o caso quando uma chave já possui uma
valor atribuído. Poderíamos optar por substituir o valor antigo pelo novo valor,
desconsiderando completamente o valor antigo. Poderíamos escolher manter o valor antigo
e ignorar o novo valor, e apenas adicione o novo valor se a chave ainda <em>não</em>
tem um valor. Ou podemos combinar o valor antigo ao valor novo.
Vejamos como fazer cada um desses!</p>
<a class="header" href="print.html#sobrescrevendo-um-valor" id="sobrescrevendo-um-valor"><h4>Sobrescrevendo um Valor</h4></a>
<p>Se inserimos uma chave e um valor em um hash map, então  se inserir essa mesma chave com
um valor diferente, o valor associado a essa chave será substituído. Eembora
o seguinte código chame <code>insert</code> duas vezes, o hash map só conterá
um par de chave/valor porque inserimos o valor da chave da equipe Blue
ambas as vezes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Blue&quot;), 25);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<p>Isso imprimirá <code>{&quot;Blue&quot;: 25}</code>. O valor original de 10 foi substituído.</p>
<a class="header" href="print.html#insira-apenas-se-a-chave-não-possui-valor" id="insira-apenas-se-a-chave-não-possui-valor"><h4>Insira Apenas se a Chave Não Possui Valor</h4></a>
<p>É comum querer verificar se uma determinada chave tem um valor e, se
não tiver, inserir um valor para ela. Os Hash maps possuem uma API especial para isso, chamada
<code>entry</code>, que leva a chave que queremos verificar como um argumento. O valor de retorno
da função <code>entry</code> é um enum, <code>Entry</code>, que representa um valor que pode
ou não existir. Digamos que queremos verificar se a chave para o time Yellow
tem um valor associado a ela. Se não tiver, queremos inserir o valor
50, e o mesmo para a equipe Blue. Com a API de entrada, o código irá parecer
com:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<p>O método <code>or_insert</code> em <code>Entry</code> retorna o valor para o <code>Entry</code> correspondente
se a chave existir, e se não, insere seu argumento como o novo valor para
esta chave e retorna a <code>Entry</code> modificada. Isso é muito mais limpo do que escrever
a lógica por nós mesmos e, além disso, trabalha-se de forma mais limpa com o borrow checker.</p>
<p>Este código imprimirá <code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>. A primeira chamada para <code>entry</code>
irá inserir a chave para a equipe Yellow com o valor 50, uma vez que o time Yellow
já não possua um valor. A segunda chamada para <code>entry</code> não vai mudar
o hash map pois o time Blue já possui o valor 10.</p>
<a class="header" href="print.html#atualize-um-valor-com-base-no-valor-antigo" id="atualize-um-valor-com-base-no-valor-antigo"><h4>Atualize um Valor com Base no Valor Antigo</h4></a>
<p>Outro caso de uso comum para hash maps é procurar o valor de uma chave e, em seguida, atualiza-la
, com base no valor antigo. Por exemplo, se quisermos contar quantas vezes
cada palavra apareceu em algum texto, podemos usar um hash map com as palavras como chaves
e incrementar o valor para acompanhar quantas vezes vimos essa palavra.
Se esta é a primeira vez que vimos uma palavra, primeiro inseriremos o valor <code>0</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
#}</code></pre></pre>
<p>Isso imprimirá <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>. O método <code>or_insert</code>
na verdade retorna uma referência mutável (<code>&amp; mutV</code>) para o valor desta
chave. Aqui nós armazenamos essa referência mutável na variável <code>count</code>, então,
para poder atribuir esse valor, devemos primeiro desreferenciar <code>count</code> usando o asterisco
(<code>*</code>). A referência mutável fica fora do escopo no final do loop <code>for</code>, então
todas essas mudanças são seguras e permitidas pelas regras de borrow.</p>
<a class="header" href="print.html#funções-hashing" id="funções-hashing"><h3>Funções Hashing</h3></a>
<p>Por padrão, <code>HashMap</code> usa uma função de hashing criptográficamente segura que pode
fornecer resistência aos ataques de Negação de Serviço (DoS). Este não é o algoritmo
mais rápido de hashing por aí, mas a compensação por uma melhor segurança que vem
com a queda na performance vale a pena. Se você testar a velocidade do seu código e encontrar
que a função de hash padrão é muito lenta para seus propósitos, você pode mudar para
outra função especificando um <em>hasher</em> diferente. Um hasher é um tipo que
implementa a trait <code>BuildHasher</code>. Vamos falar sobre traits e como
implementá-los no Capítulo 10. Você não precisa necessariamente implementar o seu próprio
hasher do zero; crates.io tem bibliotecas de hashers de uso comum que
outras pessoas compartilharam lá.</p>
<a class="header" href="print.html#sumário" id="sumário"><h2>Sumário</h2></a>
<p>Vetores, strings e hash maps irão levá-lo longe em programas onde você precisa
armazenar, acessar e modificar dados. Aqui estão alguns exercícios que você deve estar
capacitado para resolver:</p>
<ul>
<li>Dada uma lista de inteiros, use um vetor e retorne a média, a mediana
   (quando classificado, o valor na posição do meio) e modo (o valor que
   ocorre com mais frequência; um hash map será útil aqui) da lista.</li>
<li>Converta strings para Pig Latin, onde a primeira consoante de cada palavra é movida
   para o final da palavra adicionado um &quot;ay&quot; , então “first” se torna “irst-fay”.
   Palavras que começam com uma vogal recebem “hay” adicionado ao final (“apple”
   torna-se “apple-hay”). Lembre-se sobre a codificação UTF-8!</li>
<li>Usando um hash map e vetores, crie uma interface de texto para permitir que um usuário adicione
   nomes de funcionários para um departamento da empresa. Por exemplo, “Add Sally to
Engineering” ou “Add Amir to Sales”. Em seguida, deixe o usuário recuperar uma lista de todas
   as pessoas de um departamento ou todas as pessoas na empresa por departamento, ordenadas
   alfabeticamente.</li>
</ul>
<p>A documentação da API da biblioteca padrão descreve métodos que esses tipos possuem
que será útil para esses exercícios!</p>
<p>Estamos entrando em programas mais complexos onde as operações podem falhar, o que significa
que é um momento perfeito para passar pelo tratamento de erros em seguida!</p>
<a class="header" href="print.html#error-handling" id="error-handling"><h1>Error Handling</h1></a>
<a class="header" href="print.html#unrecoverable-errors-with-panic" id="unrecoverable-errors-with-panic"><h1>Unrecoverable Errors with <code>panic!</code></h1></a>
<a class="header" href="print.html#recoverable-errors-with-result" id="recoverable-errors-with-result"><h1>Recoverable Errors with <code>Result</code></h1></a>
<a class="header" href="print.html#to-panic-or-not-to-panic" id="to-panic-or-not-to-panic"><h1>To <code>panic!</code> or Not To <code>panic!</code></h1></a>
<a class="header" href="print.html#generics" id="generics"><h1>Generics</h1></a>
<a class="header" href="print.html#syntax" id="syntax"><h1>Syntax</h1></a>
<a class="header" href="print.html#traits" id="traits"><h1>Traits</h1></a>
<a class="header" href="print.html#lifetime-syntax" id="lifetime-syntax"><h1>Lifetime syntax</h1></a>
<a class="header" href="print.html#testing" id="testing"><h1>Testing</h1></a>
<a class="header" href="print.html#writing-tests" id="writing-tests"><h1>Writing tests</h1></a>
<a class="header" href="print.html#running-tests" id="running-tests"><h1>Running tests</h1></a>
<a class="header" href="print.html#test-organization" id="test-organization"><h1>Test Organization</h1></a>
<a class="header" href="print.html#an-io-project" id="an-io-project"><h1>An I/O Project</h1></a>
<a class="header" href="print.html#accepting-command-line-arguments" id="accepting-command-line-arguments"><h1>Accepting Command Line Arguments</h1></a>
<a class="header" href="print.html#reading-a-file" id="reading-a-file"><h1>Reading a File</h1></a>
<a class="header" href="print.html#improving-error-handling-and-modularity" id="improving-error-handling-and-modularity"><h1>Improving Error Handling and Modularity</h1></a>
<a class="header" href="print.html#testing-the-librarys-functionality" id="testing-the-librarys-functionality"><h1>Testing the Library's Functionality</h1></a>
<a class="header" href="print.html#working-with-environment-variables" id="working-with-environment-variables"><h1>Working with Environment Variables</h1></a>
<a class="header" href="print.html#writing-to-stderr-instead-of-stdout" id="writing-to-stderr-instead-of-stdout"><h1>Writing to <code>stderr</code> instead of <code>stdout</code></h1></a>
<a class="header" href="print.html#functional-language-features-in-rust" id="functional-language-features-in-rust"><h1>Functional Language Features in Rust</h1></a>
<a class="header" href="print.html#closures" id="closures"><h1>Closures</h1></a>
<a class="header" href="print.html#iterators" id="iterators"><h1>Iterators</h1></a>
<a class="header" href="print.html#improving-our-io-project" id="improving-our-io-project"><h1>Improving our I/O Project</h1></a>
<a class="header" href="print.html#performance" id="performance"><h1>Performance</h1></a>
<a class="header" href="print.html#more-about-cargo-and-cratesio" id="more-about-cargo-and-cratesio"><h1>More about Cargo and Crates.io</h1></a>
<a class="header" href="print.html#release-profiles" id="release-profiles"><h1>Release Profiles</h1></a>
<a class="header" href="print.html#publishing-a-crate-to-cratesio" id="publishing-a-crate-to-cratesio"><h1>Publishing a Crate to Crates.io</h1></a>
<a class="header" href="print.html#cargo-workspaces" id="cargo-workspaces"><h1>Cargo Workspaces</h1></a>
<a class="header" href="print.html#installing-binaries-from-cratesio-with-cargo-install" id="installing-binaries-from-cratesio-with-cargo-install"><h1>Installing Binaries from Crates.io with <code>cargo install</code></h1></a>
<a class="header" href="print.html#extending-cargo-with-custom-commands" id="extending-cargo-with-custom-commands"><h1>Extending Cargo with Custom Commands</h1></a>
<a class="header" href="print.html#smart-pointers" id="smart-pointers"><h1>Smart Pointers</h1></a>
<a class="header" href="print.html#concurrency" id="concurrency"><h1>Concurrency</h1></a>
<a class="header" href="print.html#is-rust-oop" id="is-rust-oop"><h1>Is Rust OOP?</h1></a>
<a class="header" href="print.html#patterns" id="patterns"><h1>Patterns</h1></a>
<a class="header" href="print.html#more-lifetimes" id="more-lifetimes"><h1>More Lifetimes</h1></a>
<a class="header" href="print.html#advanced-type-system-features" id="advanced-type-system-features"><h1>Advanced Type System Features</h1></a>
<a class="header" href="print.html#appendix" id="appendix"><h1>Appendix</h1></a>
<a class="header" href="print.html#keywords" id="keywords"><h1>Keywords</h1></a>
<a class="header" href="print.html#operators" id="operators"><h1>Operators</h1></a>
<a class="header" href="print.html#derivable-traits" id="derivable-traits"><h1>Derivable Traits</h1></a>
<a class="header" href="print.html#nightly-rust" id="nightly-rust"><h1>Nightly Rust</h1></a>
<a class="header" href="print.html#macros" id="macros"><h1>Macros</h1></a>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
